<!DOCTYPE html>
<html>

<head>
	<meta http-equiv="content-language" content="es"/>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta name="keyword" content="jmescript, evaluador, evaluacion, evaluador matematico, math parser, parser, arithmetic parser, java, miguel alejandro moreno barrientos, evaluador de expresiones matematicas, math expressions, evaluador de expresiones aritmeticas, arithmetic expressions, jme, fractal, mandelbrot" />
	<meta name="description" content="JMEScript documentación online" />
	<meta name="author" content="Miguel Alejandro Moreno Barrientos" />
    <meta name="publisher" content="Miguel Alejandro Moreno Barrientos" />
    <meta name="copyright" content="Miguel Alejandro Moreno Barrientos" />
    <meta name="distribution" content="Global" />
    <meta name="audience" content="all" />
    <meta name="robots" content="index,follow" />

	<!-- icon -->
    <link href="images_jmes/jmescript_logo.png" rel="shortcut icon" type="image/png"/>
	
	<!-- CSS -->
	<link href="../../css/jme_doc.css" rel="stylesheet" type="text/css" >
	<link href="../../css/default.css" rel="stylesheet" type="text/css" />        

	<style>
		td, th
		{
			word-break: break-all !important;
		}
	</style>

	<!-- JAVASCRIPT -->	
	<script type="text/javascript" src="../../js/jme_doc.js" charset="UTF-8"></script>
	<script type="text/javascript" src="../../js/highlight.pack.js" charset="UTF-8"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	
</head>

<body>

<header class="title" style="align-items:center;display:flex">
	<img src="images_jmes/jmescript_logo.png" width=48 style="min-width:48px"/>
	<b style="margin-left: 0.75em;font-size:1.25em">JMEScript</b>  
	<small style="margin-left: 0.5em;margin-right: 1em" class="versionJMS"></small>
	<span style="margin-left:auto">
		<a class="homepage discLink"><b>JME Homepage</b></a>
		<a href="../../index.html" class="discLink" style="color: #335"><b>Manual de Usuario de JME</b></a> 
		<a href="jmescriptgui.html" class="discLink" style="color: #335"><b><small>IDE</small> JMEScriptGUI</b></a> 
	</span> 
</header>

<hr/>

<table id="index" style="border: 1px solid black;max-width:500px;margin-left: 3%">
	<tr><td><a class="index">introduccion</a></td></tr>
	<tr><td><a class="index">sentencias</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">set</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">multiset</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">set_mut</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">swap</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">devolver</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">si</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">si_no_si</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">si_no</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">seleccionar</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">mientras</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">repetir_hasta</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">para</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">para_cada</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">fin</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">romper</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">continuar</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">bin_op</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">unary_op</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">limpiar</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">def_func</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">def_op</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">rutina</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">llamar_a</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">try</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">imprimir</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">leer</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">eval</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">pausar</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">asegurar</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">pasar</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">varmap</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">ctx2d</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_iniciar</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_finalizar</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_color</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_gradiente</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_trazo</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_punto</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_segmento</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_rectangulo</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_circunferencia</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_elipse</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_poligono</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_ruta</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_texto</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_repintar</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_limpiar</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_matriz</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_entorno</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_click</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_pulsacion</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_msj</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_leer</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_archivo</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">sql</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_conectar</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_ejecutar</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_resultado</a></td></tr>
	<tr><td>&emsp;&emsp;&emsp;<a class="index">clsl_cerrar</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">accion</a></td></tr>
	<tr><td><a class="index">vars</a></td></tr>
	<tr><td>&emsp;&emsp;■ <a class="index">ext_vars</a></td></tr>
	<tr><td><a class="index">comment</a></td></tr>
	<tr><td><b><a class="index">developers</a></b></td></tr>
	<tr><td><b>&emsp;&emsp;■ <a class="index">thread</a></b></td></tr>
	<tr><td><b>&emsp;&emsp;■ <a class="index">scriptthread</a></b></td></tr>
	<tr><td><b>&emsp;&emsp;■ <a class="index">abstractctx2d</a></b></td></tr>
	<tr><td><b>&emsp;&emsp;■ <a class="index">abstractsql</a></b></td></tr>
	<tr><td><b>&emsp;&emsp;■ <a class="index">accioncode</a></b></td></tr>
	<tr><td><a class="index">examples</a></td></tr>
</table>

<hr/>




<!-- INTRODUCTION -->
<br/>
<h2 class="subtitle" id="introduccion">Introducción a <i>JMEScript</i></h2>

<br/>
<div class="tema content">
<p class="content">
<b>JMEScript</b> es un lenguaje estructurado, dinámicamente tipado, para la creación de scripts que hacen uso
del lenguaje funcional <b>JME</b> para representación de tipos y expresiones. Es un lenguaje que nació orientado al <i>Cálculo Numérico</i>
pero no limitado a éste, ya que puede ejecutar acciones definidas sobre la propia aplicación que utilice el lenguaje para interactuar
con la propia aplicación y crear scripts y macros avanzados sobre ella.
</p>
<p class="content">
<i>JMEScript</i> consta básicamente de;<br/>
∎ estructuras de selección;&emsp;<i class="monospace">si / si no, si / si no / seleccionar</i><br/>
∎ cuatro tipos de bucles;&emsp; <i class="monospace">mientras / para / para cada / repetir hasta que</i><br/> 
∎ procedimientos locales y globales con parámetros de entrada y de entrada/salida<br/>
∎ variables dinámicas que contienen tipos JME<br/>
∎posibilidad de llamar a acciones de la propia aplicación implementante para crear scripts sobre ella<br/>
∎ creación de funciones y operadores JME definidos por el usuario<br/>
</p>
<p class="content">
Puede utilizarse <a href="https://drive.google.com/file/d/1uI_rHE_lshlhGY5PlOry3nzC9ldpTZKL/view?usp=sharing">este</a> descriptor de lenguaje definido por el usuario
(<a href="https://ivan-radic.github.io/udl-documentation/">UDL</a>)
para <a href="https://notepad-plus-plus.org/download/v7.5.8.html">Notepad++</a> que permite usar la sintaxis resaltada utilizada en los ejemplos de esta página.
</p>
</div>


<!-- SENTENCES -->
<br/>
<h2 class="subtitle" id="sentencias">Sentencias del lenguaje</h2>
<br/>

<div class="tema content">
<p class="content">
Las sentencias del lenguaje <i>JMEScript</i> se sitúan cada una <b class="subSimple">en su propia línea del código fuente</b>
del script, aunque se pueden partir en varias líneas con el separador <b>&gt;</b>. Los espacios y tabulaciones iniciales y finales son ignorados, pudiéndose usar el sangrado que se desee. 
</p>
<p class="content">
<i>JMEScript</i>, es <i class="subSimple">case-insensitive</i>, por lo que las palabras reservadas del lenguaje (<i>keywords</i>), variables, rutinas, etc.
pueden escribirse indistintamente en mayúsculas o minúsculas (el convenio usado en la documentación es minúsculas), siendo por tanto
la variable <span class="monospace">nombre</span> igual a <span class="monospace">NoMbrE</span>. 
</p>
<p class="content">
Las sentencias que terminan en '<b>inicio:</b>' son sentencias de bloque, que ejecutan o pueden ejecutar las líneas
debajo de ellas hasta llegar a su sentencia <b>fin</b> correspondiente. 
</p>
<p class="content">
Las expresiones <i>JME</i> en las sentencias se pueden rodear en caso de ambigüedad con dobles llaves; <b class="monospace">{{3x^2+1}}</b>.
</p>

<br/><br/>
<h3 class="subSection" id="set">Establecer/Borrar variable</h3>
<br/>
<p class="content">
El operador <b class="larger monospace"> := </b> permite establecer el valor de una o varias variables a un único valor mediante
una expresión JME o eliminar la/s variable/s si no se especifica ninguna expresión:
</p>
<hr class="content"/>
<p class="content">
<br/><span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/set.png" class="centerImg"/>
<br/>
</p>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/set_sample.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en consola:</span>
</p>
<div class="content console">
<p class="javaOutput">100  
falso  
[11,10,2,3,12]  
<mark class="error">&lt;&lt;&lt;ScriptException>>> en la sentencia '[#8: imprimir x]': &lt;&lt;&lt;EvaluarException>>>; identificador "x" no definido. --> ...</mark></p>
</div> 

<br/><br/>
<h3 class="subSection" id="multiset">Establecer/Borrar múltiples variables</h3>
<br/>
<p class="content">
El operador <b class="larger monospace"> :== </b> permite establecer el valor de varias variables mediante 
un vector o un diccionario o eliminar las variables.
</p>
<ul class="content">
	<li style="margin-bottom: 1em">
		Para un <span class="subSimple">vector</span>, los valores se esparcirán sobre las variables (<i>spread operator</i>).<br/>
		El número de variables debe ser menor o igual que el número de elementos del vector.<br/>
		Si no se especifica ningún valor, elimina las variables especificadas (al igual que el operador <b class="larger monospace"> := </b>).
	</li>
	<li>
		Para un <span class="subSimple">diccionario</span>, si no se especifican variables, se convertirán las claves a nombres de variable. Si la conversión de clave a
		nombre no puede realizarse, se ignorará esa clave (debe ser un identificador JME válido).
		Si se especifican variables, se tomarán los valores de las claves con el mismo nombre, sin importar mayúsculas o minúsculas. Si
		la clave no existe, la variable se elimina.
	</li>
</ul>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
</p>
<br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/multiset.png" class="centerImg"/>
	<figcaption><code>[&lt;varname> [,&lt;varname>]*] :== [&lt;vector|diccionario>]</code></figcaption>
</figure>
<br/>
<hr class="content"/>
<p class="content subSimple">Ejemplo con vector:</p>
<img class="content centerImg" src="images_jmes/multiset_sample.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en consola:</span>
</p>
<div class="content console">
<p class="javaOutput">7  I  
2  3  4  
<mark class="error">&lt;&lt;&lt;ScriptException>>> en la sentencia '[#6: imprimir x, y, z]': &lt;&lt;&lt;EvaluarException>>>; identificador "x" no definido. --> ...</mark></p>
</div>
<br/> 
<p class="content subSimple">Ejemplo con diccionario:</p>
<img class="content centerImg" src="images_jmes/multiset_sample2.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en consola:</span>
</p>
<div class="content console">
<p class="javaOutput"> { 'x': 100
   'y': 200 }

 {  'y': 200
    'b': 'hola'
   'vm': {'x'=100, 'y'=200} }</p>
</div> 

<br/><br/>
<h3 class="subSection" id="set_mut">Establecer valor de forma mutable en vector o diccionario</h3>
<br/>
<p class="content">
El operador de acceso <b class="larger monospace"> {<span style="font-weight: normal">&lt;idx></span>} </b> permite modificar/añadir/eliminar un valor 
de un vector o diccionario <i>"IN-PLACE"</i>, es decir, modificando directamente el objeto vector/diccionario.
</p>
<p class="content">
Esto puede mejorar la eficiencia en operaciones que requieran modificar grandes matrices o diccionarios sin tener que recurrir a una copia
del objeto, pero lógicamente <b>se debe programar con cuidado como cada vez que se usa programación no funcional (inmutable)</b>. <i>JME</i> siempre
trabaja de forma funcional para el usuario, al igual que <i>JMEScript</i> excepto mediante este operador de acceso.
</p>
<br/>
<ol class="content">
	<li>
		<b>caso vector:</b>
		<ul>
			<li>modificar posición;&emsp;<code>v{3}:=5</code>&emsp;modifica la posición 3 del vector a 5</li>
			<li>eliminar posición;&emsp;<code>v{3}:=</code>&emsp;elimina la posición 3 del vector (reduciendo su tamaño)</li>
			<li>modificar rango;&emsp;<code>v{[2,4]}:=0</code>&emsp;establece a 0 las posiciones 2,3,4 del vector</li>
			<li>eliminar rango;&emsp;<code>v{[2,4]}:=</code>&emsp;elimina las posiciones 2,3,4 del vector (reduciendo su tamaño)</li>
			<li>insertar en posición;&emsp;<code>v{3b}:=5</code>&emsp;inserta en la posición 3 del vector un 5, desplazando los elementos siguientes 
			una posición y aumentando el tamaño. Se debe especificar la posición con un <i>EnteroGrande</i></li>
		</ul>
	</li>
	<li>
		<b>caso diccionario:</b>
		<ul>
			<li>modificar o crear clave;&emsp;<code>d{'key'}:=5</code>&emsp;crea clave y valor {'key',5} o la modifica</li>
			<li>eliminar clave;&emsp;<code>d{'key'}:=</code>&emsp;elimina la clave 'key' y su valor si existe, en caso contrario no tiene efecto</li>
		</ul>
	</li>
</ol>
<hr class="content"/>
<br/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
</p>
<br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/set_mutable.png" class="centerImg"/>
	<figcaption><code>&lt;varname> { &lt;idx|key> } := [&lt;valor>]</code></figcaption>
</figure>
<br/>
<hr class="content"/>
<p class="content">
<span class="subSimple">Operador sobre vector:</span>
</p>
<img class="content centerImg" src="images_jmes/set_mutable_sample.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en consola:</span>
</p>
<div class="content console">
<p class="javaOutput">0:  ['a','b','c','d']  
1:  ['a','z','c','d']  
2:  ['a','c','d']  
3:  ['inicio','a','c','d','fin']  
4:  ['inicio','fin']  
5:  [0,0]  
</p>
</div> 
<br/>
<p class="content">
<span class="subSimple">Operador sobre diccionario:</span>
</p>
<img class="content centerImg" src="images_jmes/set_mutable_sample2.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en consola:</span>
</p>
<div class="content console">
<p class="javaOutput">0:  {'p'=[1,2], 'q'=[0,1], 'r'=5, 'x'=1, 'y'=-3, 'z'=0}  
1:  {'p'='__null__', 'q'=[0,1], 'r'=5, 'x'=1, 'y'=-3, 'z'=0}  
2:  {'q'=[0,1], 'r'=5, 'x'=1, 'y'=-3, 'z'=0}  
3:  {'q'=[0,1], 'r'=5, 'x'=1, 'y'=-3, 'z'=0, 'p'=[-2,-3]}  
</p>
</div>
<br/> 
<p class="content">
<span class="subSimple">Operador sobre matriz:</span>
</p>
<img class="content centerImg" src="images_jmes/set_mutable_matriz_sample.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en consola:</span>
</p>
<div class="content console">
<p class="javaOutput">| 8  0  8  |
| 0  5  45 |
| 0  0  1  |


| 8  0   8  |
| 0  5  100 |
| 0  0   1  |
</p>
</div> 

<br/><br/>
<h3 class="subSection" id="swap">Intercambiar variables</h3>
<br/>
<p class="content">
La sentencia <b>intercambiar</b> o <b>swap</b> permite intercambiar dos variables sin usar una tercera auxiliar.
</p>
<p class="content">
La sentencia también intercambia si una variable está indefinida, haciendo que sea la otra la indefinida.
</p>
<hr class="content"/>
<p class="content">
<br/><span class="subSimple">Diagrama sintáctico:</span>
</p>
<br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/swap.png" class="centerImg"/>
	<figcaption><code>intercambio|swap &lt;var1> [,] &lt;var2></code></figcaption>
</figure>
<br/>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/swap_sample.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en consola:</span>
</p>
<div class="content console">
<p class="javaOutput">'a' y 'b' intercambiados:  
a:  2  
b:  1  
borrar 'b' e intercambiar con 'a':  
b:  2  
a indefinido:  verdadero
</p>
</div> 

<br/><br/>
<h3 class="subSection" id="devolver">Devolver resultado</h3>
<br/>
<p class="content">
La sentencia <b>devolver</b> termina el script y devuelve opcionalmente un resultado.
Si no se especifica el resultado, el valor devuelto es <b>null</b>.
</p>
<p class="content">
Si se usa esta sentencia dentro de una rutina, <span class="subSimple">termina todo el script</span> (el significado no es el mismo de <i>return</i> en otros lenguajes).
Las rutinas se rompen con <b>romper rutina</b>.
</p>
<hr class="content"/>
<p class="content subSimple">Diagrama sintáctico:</p>
<br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/devolver.png" class="centerImg content"/>
	<figcaption><code>devolver [&lt;valor_devuelto>]</code></figcaption>
</figure>
<br/>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/devolver_sample.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en REPL:</span>
</p>
<div class="content console">
<p class="javaOutput">72  

	 ==> Texto: 'valor no válido'

	(parse: 475µs(3%) / eval: 18,1ms(97%) / total: 18,6ms)</p>
</div> 
<br/>
<div class="content console">
<p class="javaOutput">37  

	 ==> RealDoble: 1370

	(parse: 741µs(6%) / eval: 12,1ms(94%) / total: 12,9ms)</p>
</div> 
<p class="content">

<br/><br/>
<h3 class="subSection" id="si">Selección 'Si'</h3>
<br/>
<p class="content">
La sentencia <b>si</b> selecciona el código de su bloque según una condición.
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/si.png" class="centerImg"/>
<br/>
</p>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/si_sample.png"/>
<br/>
<p class="content">
<span class="subSimple">Valor devuelto:</span>
</p>
<div class="content console">
<p class="javaOutput">'no es primo'</p>
</div> 

<br/><br/>
<h3 class="subSection" id="si_no_si">Selección 'Si no, si'</h3>
<br/>
<p class="content">
La sentencia <b>si no, si</b> selecciona el código de su bloque según una condición si las
condiciones 'si' y 'si no, si' previas han fallado. Esta sentencia <span class="subSimple">siempre debe seguir</span>
a un bloque 'si', u otro 'si no, si'.
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/si_no_si.png" class="centerImg"/>
<br/>
</p>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/si_no_si_sample.png"/>
<br/>
<p class="content">
<span class="subSimple">Valor devuelto:</span>
</p>
<div class="content console">
<p class="javaOutput">'notable'</p>
</div> 

<br/><br/>
<h3 class="subSection" id="si_no">Selección 'Si no'</h3>
<br/>
<p class="content">
La sentencia <b>si no</b> selecciona el código de su bloque si las
condiciones 'si' y 'si no, si' previas han fallado. Esta sentencia <span class="subSimple">siempre debe seguir</span>
a un bloque 'si' o 'si no, si'.
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/si_no.png" class="centerImg"/>
<br/>
</p>
<hr class="content"/>
<p class="content">
Ver ejemplo previo de la sentencia <b>si no, si</b>.
</p>

<br/><br/>
<h3 class="subSection" id="seleccionar">Selección de casos 'Seleccionar'</h3>
<br/>
<p class="content">
La sentencia <b>seleccionar</b> ejecuta el caso/casos que cumplan con la condición especificada o con el valor dado.
</p>
<p class="content">
Puede definirse un caso por defecto que se ejecutará en caso de que los demás no se cumplan (en <i>multicaso</i> ejecuta siempre).
Debe definirse <i class="subSimple">al final</i> mediante <b>caso*</b>.
</p>
<p class="content">
Si se añade * a <i>seleccionar</i>, se utilizará el <b>multicaso</b>, se ejecutarán todos los casos que cumplan la condición
en lugar de sólo el primero que la cumpla.
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/seleccionar.png" class="centerImg"/>
	<figcaption><code>seleccionar[*] &lt;valor> inicio: [caso &lt;valor|condición> inicio:]* [caso* inicio:]</code></figcaption>
</figure>
<br/>
<hr class="content"/>
<p class="content">
	<img class="content centerImg" src="images_jmes/seleccionar_sample.png"/>
</p>
<p class="content">
<span class="subSimple">Salida:</span>
</p>
<div class="content console">
<p class="javaOutput">'>90'  
'default'  
'default'  
'default'  
'>90'  
'default'  
'default'  
'default'  
'1'  
'default'  
</p>
</div>
<br/><br/>
<p class="content">
	<img class="content centerImg" src="images_jmes/seleccionar_sample_2.png"/>
</p>
<p class="content">
<span class="subSimple">Salida:</span>
</p>
<div class="content console">
<p class="javaOutput">item: 'b'  
  
'b|d'  
'a|b'
</p>
</div>


<br/><br/>
<h3 class="subSection" id="mientras">Bucle 'Mientras'</h3>
<br/>
<p class="content">
La sentencia <b>mientras</b> es un bucle pre-condición que repite un bloque de código mientras la condición es verdadera.
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/mientras.png" class="centerImg"/>
<br/>
</p>
<hr class="content"/>
<p class="content">Este script añade tiradas de un dado hasta obtener un 6:</p>
<img class="content centerImg" src="images_jmes/mientras_sample.png"/>
<br/>
<p class="content">
<span class="subSimple">Valor devuelto:</span>
</p>
<div class="content console">
<p class="javaOutput">[2,5,1,3,5,2,5,3,3,6]</p>
</div>

<br/><br/>
<h3 class="subSection" id="repetir_hasta">Bucle 'Repetir hasta que'</h3>
<br/>
<p class="content">
La sentencia <b>repetir hasta que</b> es un bucle post-condición que repite un bloque de código <b>hasta que la condición es verdadera</b> ejecutando una o más veces.
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/repetir_hasta.png" class="centerImg"/>
<br/>
</p>
<hr class="content"/>
<p class="content">Este script añade tiradas de un dado hasta obtener un 6 (obsérvese que 'n' no necesita estar definida al principio del bucle):</p>
<img class="content centerImg" src="images_jmes/repetir_hasta_sample.png"/>
<br/>
<p class="content">
<span class="subSimple">Valor devuelto:</span>
</p>
<div class="content console">
<p class="javaOutput">[3,1,3,6]</p>
</div>

<br/><br/>
<h3 class="subSection" id="para">Bucle 'Para'</h3>
<br/>
<p class="content">
La sentencia <b>para</b> es un bucle contador que repite un bloque de código en el rango especificado.
<br/>Pueden usarse números enteros o reales para especificar el rango, aunque los reales pueden acarrear 
problemas de precisión. 
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/para.png" class="centerImg"/>
<br/>
</p>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/para_sample1.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida consola:</span>
</p>
<div class="content console">
<p class="javaOutput">2  3  5  7  11  13  17  19  23  </p>
</div> 
<hr class="content"/>
<img class="content centerImg" src="images_jmes/para_sample2.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida consola:</span>
</p>
<div class="content console">
<p class="javaOutput">0  0.1  0.2  0.30000000000000004  0.4  0.5  0.6  0.7  0.7999999999999999  0.8999999999999999  0.9999999999999999  1.0999999999999999  1.2  1.3  1.4000000000000001  
0  0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9  1  1.1  1.2  1.3  1.4  1.5  </p>
</div>

<br/><br/>
<h3 class="subSection" id="para_cada">Bucle 'Para cada'</h3>
<br/>
<p class="content">
La sentencia <b>para cada</b> es un bucle que itera sobre elementos JME <i>iterables</i> (elementos de <b>vector</b>,
entradas de <b>diccionario</b> y caracteres de <b>texto</b>).
</p>
<p class="content">
El bucle permite especificar, además de la variable de iteración que contiene cada elemento particular, una variable contadora.
Si esta variable no está inicializada o está inicializada a un valor no entero, se inicializa a <b>1</b> por defecto o al valor especificado. 
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
</p>
<br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/para_cada.png" class="centerImg"/>
	<figcaption><code>para cada [&lt;varidx> [:= &lt;idx>] ,] &lt;varname> en &lt;iterable> inicio:</code></figcaption>
</figure>
<br/>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/para_cada_sample1.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en consola:</span>
</p>
<div class="content console">
<p class="javaOutput">'leido un 4'  
'leido un 2'  
'leido un 7'  
'leido un 1'  
'leido un 9'  
'leido un 0'  </p>
</div>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/para_cada_sample2.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en consola:</span>
</p>
<div class="content console">
<p class="javaOutput">'caracter 1: 'H''  
'caracter 2: 'o''  
'caracter 3: 'l''  
'caracter 4: 'a''  
'caracter 5: ' ''  
'caracter 6: 'M''  
'caracter 7: 'u''  
'caracter 8: 'n''  
'caracter 9: 'd''  
'caracter 10: 'o''  
'caracter 11: '!''  

	 ==> VectorEvaluado: 

		| 4   'a' |
		| 5   ' ' |
		| 6   'M' |
		| 7   'u' |
		| 8   'n' |
		| 9   'd' |
		| 10  'o' |
		| 11  '!' |


	(parse: 651µs(2%) / eval: 27,7ms(98%) / total: 28,4ms)</p>
</div>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/para_cada_sample3.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en consola:</span>
</p>
<div class="content console">
<p class="javaOutput">'usuario: 'viviana', contraseña: 'ridan''  
'usuario: 'user29', contraseña: 'masca3''  
'usuario: 'pepe', contraseña: 1234'  </p>
</div>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/para_cada_sample4.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en consola:</span>
</p>
<div class="content console">
<p class="javaOutput">'odnum aloh'  
verdadero  </p>
</div>

<br/><br/>
<h3 class="subSection" id="fin">Finalizador de bloque</h3>
<br/>
<p class="content">
La sentencia <b>fin</b> indica el final de un bloque, y debe ir en concordancia
con el inicio de bloque que se desea cerrar. Una sentencia de bloque sin 'fin' o 
un 'fin' sin sentencia de bloque provocará un error.
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/fin.png" class="centerImg"/>
<br/>
</p>

<br/><br/>
<h3 class="subSection" id="romper">Romper bucle o rutina</h3>
<br/>
<p class="content">
La sentencia <b>romper</b> finaliza incondicionalmente un bucle o una rutina.
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/romper.png" class="centerImg"/>
<br/>
</p>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/romper_sample1.png"/>
<br/>
<p class="content">
<span class="subSimple">Valor devuelto:</span>
</p>
<div class="content console">
<p class="javaOutput">[2,2,5,1,2,2,2,4,2,4,2,5,4,4,6]</p>
</div>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/romper_sample2.png"/>
<br/>
<p class="content">
<span class="subSimple">Valor devuelto:</span>
</p>
<div class="content console">
<p class="javaOutput">[93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000,verdadero]</p>
</div>

<br/><br/>
<h3 class="subSection" id="continuar">Continuar</h3>
<br/>
<p class="content">
La sentencia <b>continuar</b> salta a la siguiente iteración del bucle.
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/continuar.png" class="centerImg"/>
<br/>
</p>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/continuar_sample.png"/>
<br/>
<p class="content">
<span class="subSimple">Valor devuelto:</span>
</p>
<div class="content console">
<p class="javaOutput">'El cielo est entrbicudriquindo'</p>
</div>

<br/><br/>
<h3 class="subSection" id="bin_op">Asignación binaria implícita</h3>
<br/>
<p class="content">
Esta sentencia permite autoasignar implícitamente el resultado de una operación binaria en la que 
el valor de la variable es el primer operando.  
</p>
<p class="content">
Es una forma corta del operador de asignación <b>:=</b> cuando la expresión es una operación binaria,
por tanto <b class="monospace larger">a&lt;operador>=&lt;expresión></b> es equivalente a <b class="monospace larger">a:=a&lt;operador>&lt;expresión></b>
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/operador_binario.png" class="centerImg"/>
<br/>
</p>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/operador_binario_sample.png"/>
<br/>
<p class="content">
<span class="subSimple">Valor devuelto:</span>
</p>
<div class="content console">
<p class="javaOutput">314.1</p>
</div>

<br/><br/>
<h3 class="subSection" id="unary_op">Asignación unaria implícita</h3>
<br/>
<p class="content">
Esta sentencia permite autoasignar implícitamente el resultado de una operación unaria en la que 
el valor de la variable es el operando.
</p>
<p class="content">
Es una forma corta del operador de asignación <b>:=</b> cuando la expresión es una operación unaria,
por tanto <b class="monospace larger">a&lt;operador></b> es equivalente a <b class="monospace larger">a:=a&lt;operador></b>
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/operador_unario.png" class="centerImg"/>
<br/>
</p>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/operador_unario_sample.png"/>
<br/>
<p class="content">
<span class="subSimple">Valor devuelto:</span>
</p>
<div class="content console">
<p class="javaOutput">720</p>
</div>

<br/><br/>
<h3 class="subSection" id="limpiar">Limpiar variables</h3>
<br/>
<p class="content">
Esta sentencia actúa como el operador <b class="larger">:== </b> cuando elimina las variables del mapa de variables
con la diferencia de que además <b>sugiere</b> al <i>depurador de memoria de JAVA</i> que libere la memoria reservada por la variable.
Esto puede ser especialmente útil con variables que almacenen un valor extremadamente grande y que ya no sean necesarias
en el resto de la ejecución del script. Además puede limpiar todas las variables del ámbito con el modificador *.
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/limpiar.png" class="centerImg"/>
<br/>
</p>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/limpiar_sample.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en consola:</span>
</p>
<div class="content console">
<p class="javaOutput"><mark class="error">&lt;&lt;&lt;ScriptException>>> en la sentencia '[#16: imprimir a, b, x, y]': &lt;&lt;&lt;EvaluarException>>>; identificador "a" no definido. --> ...</mark></p>
</div>

<br/><br/>
<h3 class="subSection" id="def_func">Definir función JME de usuario</h3>
<br/>
<p class="content">
Esta sentencia establece una función JME definida por el usuario.
</p>
<p class="content">
Las funciones definidas en el script permanecen en el mapa de funciones de JME al terminal
el script, por lo que pueden usarse scripts como bibliotecas de funciones.
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/def_func.png" class="centerImg"/>
<br/>
</p>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/def_func_sample.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en consola:</span>
</p>
<div class="content console">
<p class="javaOutput">-11  

[[[[[[[[[['Hola Mundo']]]]]]]]]]  

[[falso,falso,'valor:verdadero'],[falso,verdadero,'valor:verdadero'],[verdadero,falso,'valor:falso'],[verdadero,verdadero,'valor:falso']]  

[7,9]  

[0,1,2,3,4,5,6,7,8,9,30,31,32,33,34]  </p>
</div>

<br/><br/>
<h3 class="subSection" id="def_op">Definir operador JME de usuario</h3>
<br/>
<p class="content">
Esta sentencia establece un operador unario o binario JME definido por el usuario.
</p>
<p class="content">
Los operadores definidos en el script permanecen en el mapa de operadores de JME al terminal
el script, por lo que pueden usarse scripts como bibliotecas de operadores.
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/def_op.png" class="centerImg"/>
<br/>
</p>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/def_op_sample.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en consola:</span>
</p>
<div class="content console">
<p class="javaOutput">'edad: 38'  

[7,8,9,10]  

999999999999999999990000000000000000000199999999999999999991  </p>
</div>

<br/><br/>
<h3 class="subSection" id="rutina">Crear rutina</h3>
<br/>
<p class="content">
Esta sentencia crea una rutina o procedimiento. Las rutinas <i>JMEScript</i> no devuelven un valor
como las funciones, pero permiten la entrada y salida de datos mediante parámetros formales 
de entrada y entrada/salida (precedidos por <i>var</i>). Las rutinas pueden ejecutarse mediante
la sentencia <b>llamar a</b>.
</p>
<p class="content">
Las rutinas pueden definirse en cualquier punto del programa y ser llamadas en cualquier punto,
no siendo necesario definirlas antes de llamarlas. En los ejemplos de esta página se sigue el 
convenio de definirlas al principio. También se pueden anidar (definir una dentro de otra) para
indicar simbólicamente que una es auxiliar de otra, pero para el compilador es indiferente el lugar
de declaración, son igualmente visibles en todo el script.
</p>
<p class="content">
Los parámetros formales son variables solo definidas en el ámbito de la rutina. En una rutina no
global, toda variable definida dentro de la rutina es local a la rutina. Las variables del programa 
principal no son accesibles en la rutina.
</p>
<ul class="content">
	<li>Los parámetros formales de entrada no incluyen el modificador <i><b>var</b></i>,
	y permiten la entrada de valores a la rutina.</li>
	<li>Los parámetros formales de E/S están precedidos por <i><b>var</b></i> y permiten 
	introducir valores mediante una variable inicializada (opcionalmente) y devolver un 
	valor a través de esa variable.</li>
</ul>
<p class="content">
Una rutina termina al finalizar su bloque de código, o al usar la sentencia <b>romper rutina</b>, o
al usar la sentencia <b>devolver</b>, pero esta última termina todo el script, no solo la rutina.
</p>  
<p class="content">
<i>Nota</i>: antes de definir una rutina <i>JMEScript</i> es preferible comprobar si existe
alguna expresión <i>JME</i> que realice fácilmente la misma tarea. Por lo general será más simple
y mucho más eficiente. 
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
</p>
<figure style="margin: auto">
	<img src="images_jmes/rutina.png" class="centerImg"/>
	<figcaption><code>procedimiento|rutina [global] &lt;nombre_funcion> ( [[var] &lt;param> [,[var] &lt;param>]*] ) inicio:</code></figcaption>
</figure>
<br/>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/rutina_sample2.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en consola:</span>
</p>
<div class="content console">
<p class="javaOutput">7  
4  </p>
</div>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/rutina_sample.png"/>
<br/>
<p class="content">
<span class="subSimple">Valor devuelto:</span>
</p>
<div class="content console">
<p class="javaOutput">[93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000,verdadero]</p>
<hr class="content"/>
</div>
<br/>
<h3 class="content subSection" id="rutina" style="opacity: 67%">+ Rutinas globales</h3>
<br/>
<p class="content">
Las rutinas o procedimientos globales (usan la cláusula <b>global</b>) difieren de las anteriores en que pueden acceder y modificar las
variables del ámbito en el que son llamadas, además de poder definir nuevas variables en su cuerpo.
Si son llamadas desde el <b><code>TOP-LEVEL</code></b> pueden acceder a la variables de éste, si se llaman
desde otra rutina, pueden acceder a las de ésta.
</p>
<p class="content">
Si se define una variable nueva en una rutina global, será visible también en el ámbito previo.
</p>
<p class="content">
El comportamiento de los parámetros formales es idéntico al de las rutinas "locales".
</p>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/rutina_global_sample_.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en consola:</span>
</p>
<div class="content console">
<p class="javaOutput">var_outer visible en inner:  100  
var_inner visible en outer:  []  
var_inner no visible en TOP-LEVEL   
var_inner visible en TOP-LEVEL:  []  
</p>
</div>
<br/>
<p class="content subSimple">Ejemplo que usa rutinas globales:</p>
<p class="content" style="font-size: 1.5em">
	<a href="scripts/grafos_jme.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/bola_loca.jmes"><b>grafos_jme.jmes</b></a>
</p>

<br/><br/>
<h3 class="subSection" id="llamar_a">Llamar a rutina</h3>
<br/>
<p class="content">
La sentencia <b>llamar a</b> ejecuta una rutina <i>JMEScript</i>.
</p>
<p class="content">
La cláusula <i>llamar a</i> es opcional, basta con el nombre de la rutina, pero clarifica para no confundir 
con funciones <i>JME</i>. Pueden verse ejemplos en la sentencia anterior de creación de rutina.  
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
</p>
<br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/llamar_a.png" class="centerImg"/>
	<figcaption><code>[llamar a] &lt;nombre_rutina> ( [&lt;param> [, &lt;param>]*] )</code></figcaption>
</figure>

<br/><br/>
<h3 class="subSection" id="try">Intentar/Capturar</h3>
<br/>
<p class="content">
Las sentencias <b>intentar</b> y <b>capturar</b> permiten controlar excepciones ocurridas en el bloque de código dentro de <i>intentar</i>, 
equivalentemente a los bloques <i>try/catch</i> de la mayoría de lenguajes.
</p>
<p class="content">
El bloque <i>capturar</i> puede opcionalmente capturar en una variable un diccionario con la información de la excepción, con las claves
<b><code>tipo, exmsg, sentencia, linea, causa</code></b>
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagramas sintácticos:</span>
</p>
<br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/intentar.png" class="centerImg"/>
	<figcaption><code>intentar inicio:</code></figcaption>
	<figcaption><code>capturar [en &lt;varname>] inicio:</code></figcaption>
</figure>
<br/>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/intentar_sample.png"/>
<br/>
<p class="content subSimple">Cuatro salidas en consola:</p>
<div class="content console">
<p class="javaOutput">Aseveración errónea:
		&lt;&lt;&lt;AssertException>>> en condicion "'Hola'='HOLA'"
</p>
</div>
<br/>
<div class="content console">
<p class="javaOutput">ScriptException:
 {      'tipo': 'jme.script.ScriptException'
       'causa': '__null__'
       'exmsg': '&lt;&lt;&lt;ScriptException>>> en la sentencia [#11: a, b :== [1]]: Imposible esparcir, el nº de variables es '2' y los valores '1''
   'sentencia': 'a,b:==[1]'
       'linea': 11 }
</p>
</div>
<br/>
<div class="content console">
<p class="javaOutput">error no esperado:
 {      'tipo': 'jme.script.ScriptException'
       'causa': {'tipo'='jme.excepciones.EvaluarException', 'causa'='__null__', 'exmsg'='&lt;&lt;&lt;EvaluarException>>>; identificador "x" no definido.'}
       'exmsg': '&lt;&lt;&lt;ScriptException>>> en la sentencia [#8: imprimir x]: &lt;&lt;&lt;EvaluarException>>>; identificador "x" no definido.'
   'sentencia': 'imprimir x'
       'linea': 8 }
</p>
</div>
<br/>
<div class="content console">
<p class="javaOutput">Operación no válida:
		&lt;&lt;&lt;OperacionException>>> en operador [ + ] : operacion no definida --> (RealDoble:3)+(Texto:'')  
</p>
</div>

<br/><br/>
<h3 class="subSection" id="imprimir">Imprimir en salida por defecto</h3>
<br/>
<p class="content">
Esta sentencia vuelca valores en el 'stream' especificado (por defecto <b class="monospace">System.out</b>). 
</p>
<p class="content">
Si se usa sin ningún argumento imprime un salto de línea. Una coma al final evita el salto de línea al terminar.
</p>
<p class="content">
La cláusula <b>vertical</b> imprime las entradas separadas por saltos de línea en lugar de doble espacio.
Para matrices y diccionarios, la salida es en formato vertical (más legible).
</p>
<p class="content">
La cláusula <b>msj</b> imprime el tipo texto sin comillas, para el resto de datos no tiene efecto.
</p>
<p class="content">Nota: la salida por defecto es <b><code>System.out</code></b>, puede modificarse con el método <code>Script#setSalida</code>.
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
</p>
<br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/imprimir.png" class="centerImg"/>
	<figcaption><code>imprimir [msj] [vertical] [&lt;expresion> [, &lt;expresion>]*] [,]</code></figcaption>
</figure>
<br/>

<hr class="content"/>
<img class="content centerImg" src="images_jmes/imprimir_ejemplo.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en consola:</span>
</p>
<div class="content console">
<p class="javaOutput">Ejemplo de 'imprimir'  
en horizontal:  
2  3  4  
en vertical:  
-1
-2
-3

matriz de escalada en vertical:
| 2  0  0 |
| 0  3  0 |
| 0  0  1 |
diccionario en vertical:  
 { 'a': 3
   'b': 100
   'c': 21 }

'FIN'  

</p>
</div>

<br/><br/>
<h3 class="subSection" id="leer">Lectura desde entrada por defecto</h3>
<br/>
<p class="content">
Esta sentencia lee una cadena en el 'stream' especificado (por defecto <b class="monospace">System.in</b>). 
</p>
<p class="content">
La cadena leída se evaluará y asignará a la variable especificada. Si se añade el modificador
<b>cadena</b>, la cadena se convertirá a texto sin evaluar, y no serán necesarias comillas.
Si se añade el modificador <b>exp</b>, la cadena se convertirá en una expresión que se evaluará
cada vez que se utilice la variable.
Si hay un error en la expresión, la variable quedará indefinida (incluso si antes estaba definida).
Se puede especificar un mensaje en la salida al pedir el dato.
</p>
<p class="content">
<i>Notas</i>: para que esta sentencia funcione, la entrada por defecto del script debe permitir la
introducción de datos por el usuario (mediante consola, diálogo, ...). El script estará detenido hasta la
introducción del dato.
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/leer.png" class="centerImg"/>
<br/>
</p>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/leer_sample1.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en REPL:</span>
</p>
<div class="content console">
<p class="javaOutput">x? 100
y? -30
x? 15^2-1
y? 10+20
x? 0
y? -10000
x? pi
y? _e
x? 

	 ==> VectorEvaluado: 

		|        100                -30        |
		|        224                30         |
		|         0               -10000       |
		| 3.141592653589793  2.718281828459045 |


	(parse: 237ms(0%) / eval: 48,423s(100%) / total: 48,66s)</p>
</div>

<br/><br/>
<h3 class="subSection" id="eval">Evaluar expresión</h3>
<br/>
<p class="content">
Evalúa una expresión sin asignar resultado <small>(v0.1.1)</small>. 
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/eval.png" class="centerImg"/>
<br/>
</p>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/eval_sample.png"/>
<br/>

<br/><br/>
<h3 class="subSection" id="pausar">Pausar script</h3>
<br/>
<p class="content">
Pausa el hilo de ejecución del script. Sólo puede ser reanudado desde otro hilo mediante el método JAVA&emsp;<b>Object#notify</b>.
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/pausa.png" class="centerImg"/>
<br/>
</p>

<br/><br/>
<h3 class="subSection" id="asegurar">Asegurar</h3>
<br/>
<p class="content">
Esta sentencia lanza una excepción o un mensaje dado en caso de que no se cumpla una condición <i class="comment">(assert sentence)</i>.
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
</p>
<br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/asegurar.png" class="centerImg"/>
	<figcaption><code>asegurar &lt;condición> [msj &lt;mensaje>]</code></figcaption>
</figure>
<br/>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/asegurar_sample.png"/>
<br/>
<p class="content subSimple">Salida en consola:</p>
<div class="content console">
<p class="javaOutput">No es primo
jme.script.ScriptException: &lt;&lt;&lt;ScriptException>>> en la sentencia [#5: asegurar primo(10)]: Error al asegurar [primo(10)]
	at jme.script.Asegurar.ejecutar(Asegurar.java:116)
	at jme.script.Script.ejecutar(Script.java:345)
	at jme.script.ScriptThread.run(ScriptThread.java:99)
</p>
</div>

<br/><br/>
<h3 class="subSection" id="pasar">Sentencia vacía</h3>
<br/>
<p class="content">
Sentencia vacía, es equivalente a una línea en blanco.
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<img src="images_jmes/pasar.png" class="centerImg"/>
<br/>
</p>

<br/><br/>
<h3 class="subSection" id="varmap">VarMap</h3>
<br/>
<p class="content">
Esta sentencia permite acceder/modificar el mapa de variables.
</p>
<ul class="content">
	<li>obtener <b>COPIA</b> del mapa:&emsp;<code>varmap en vm</code>&emsp;copia el mapa de variables en <i>vm</i></li>
	<li>obtener valor:&emsp;<code>varmap 'x' en v</code>&emsp;obtiene el valor de 'x' en <i>v</i> si existe, en caso 
	contrario no tiene efecto</li>
	<li>borrar variable:&emsp;<code>varmap borrar 'x'</code>&emsp;borra variable <i>x</i> si existe,
	en caso contrario no tiene efecto</li>
	<li>establecer/modificar valor:&emsp;<code>varmap 'x':=100</code>&emsp;establece <i>x</i> a 100</li>
</ul>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
</p>
<br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/varmap.png" class="centerImg"/>
	<figcaption><code>varmap [[&lt;vartxt>] en &lt;varname>] | [borrar &lt;vartxt>] | [ &lt;vartxt> := &lt;valor> ]</code></figcaption>
</figure>
<br/>
<hr class="content"/>
<img class="content centerImg" src="images_jmes/varmap_sample.png"/>
<br/>
<p class="content subSimple">Salida en consola:</p>
<div class="content console">
<p class="javaOutput"> { 'var6': 4
   'var5': 3
   'var4': 5
   'var3': 1
   'var2': 3
   'var1': 2 }

var1 vale 2  
  
 { 'var6': 4
   'var5': 3
   'var4': 5
   'var3': 1
   'var2': 3 }
</p>
</div>

<br/><br/>
<h3 class="subSection" id="ctx2d">Sentencia de contexto gráfico</h3>
<br/>
<p class="content">
Ejecuta las primitivas gráficas 2D de JMEScript; dibuja líneas, polígonos, puntos,&hellip; , muestra mensajes de usuario, 
entrada de datos de usuario, lectura de pulsaciones, toques/clicks, &hellip;. 
</p>
<p class="content">
Para ejecutar esta sentencia debe estar definido un contexto gráfico en el sistema que ejecute <i>JME/JMEScript</i>.
En <b class="small"><a href="jmescriptgui.html" class="discLink" style="color: #335">JMEScriptGUI</a></b> para escritorio pueden ejecutarse 
todas las primitivas. En el apartado para desarrolladores se explica como implementar un contexto gráfico para <i>JMEScript</i> 
a partir de la clase <code>AbstractPrimitivas2D</code>. 
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d.png" class="centerImg"/>
	<figcaption><br/><code>ctx2d [#&lt;indice-lienzo>#] &lt;claúsula-ctx2d></code></figcaption>
</figure>
<br/>
<hr class="content"/>

<p class="content">
El índice del lienzo por defecto es 1, e indica el lienzo a utilizar en caso de múltiples lienzos en el script.
</p>

<div class="content">

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_iniciar">+ Cláusula <ins>iniciar</ins></h3>
<br/>
<div class="content">
<p>
La cláusula <b>iniciar</b> inicializa el contexto gráfico (típicamente crear un lienzo para el dibujo y mostrarlo).
Permite definir el tamaño, posición y título del lienzo que lo contiene.
</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_iniciar.png" class="centerImg"/>
	<figcaption><br/><code>iniciar &lt;ancho> &lt;alto> [posicion &lt;posicion>] [titulo &lt;titulo>]</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Snippet de código de ejemplo de juego de bola móvil (ver ejemplos)</figcaption>
	<img src="images_jmes/ctx2d_iniciar_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/bola_loca.gif" height="600" class="centerImg"/>
</figure>
<p class="content" style="font-size: 1.5em">
	<a href="scripts/bola_loca.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/bola_loca.jmes"><b>bola_loca.jmes</b></a>
</p>
</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_finalizar">+ Cláusula <ins>finalizar</ins></h3>
<br/>
<div class="content">
<p>
La cláusula <b>finalizar</b> finaliza el contexto gráfico (típicamente cierra el lienzo o lo inhabilita) especificado.
También permite cerrar todos los lienzos si hay más de uno con *.
</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_finalizar.png" class="centerImg"/>
	<figcaption><br/><code>finalizar [*]</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Snippet de código de ejemplo de juego de bola móvil (ver ejemplos)</figcaption>
	<img src="images_jmes/ctx2d_finalizar_ejemplo.png" class="centerImg"/>
</figure>
<br/>
</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_color">+ Cláusula <ins>color</ins></h3>
<br/>
<div class="content">
	<p>
	Establece el color de <b>línea</b>, de <b>relleno</b> y <b>fondo</b> del lienzo.
	</p>
	<p>El color puede establecerse mediante</p>
	<ul>
		<li>un vector <code>[rojo,verde,azul]</code> o <code>[rojo,verde,azul,trasparencia]</code>,
			con valores <code>[0-255]</code>
		</li>
		<li>una cadena de color HTML, ejemplo: <code>'#3F2AB0'</code>, <code>'#FFFFFF77'</code>		
		</li>
		<li>un entero RGBA de 32 bits con el patrón 
			&emsp;<code>[bit 31]</code><font color="gray">■■■■■■■■</font>
			<font color="red">■■■■■■■■</font> 
			<font color="green">■■■■■■■■</font>
			<font color="blue">■■■■■■■■</font><code>[bit 0]</code>
		</li>
	</ul>	
	<p>Si no se establece un determinado color, se mantiene el valor previo.</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_color.png" class="centerImg"/>
	<figcaption><br/><code>color [linea &lt;color>] [relleno &lt;color>] [fondo &lt;color>]</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo que dibuja dos rectángulos de diferentes colores en diferentes formatos de color</figcaption>
	<img src="images_jmes/ctx2d_color_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/ctx2d_color_ejecucion_ejemplo.png" class="centerImg"/>
</figure>
<br/>
</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_gradiente">+ Cláusula <ins>gradiente</ins></h3>
<br/>
<section class="content">
<p>Aplica un gradiente de color lineal o radial a relleno y trazo.</p>
<p>El <code>inicio</code> y <code>final</code> indican el comienzo del primer color y último en gradiente lineal o centro y foco en radial.<br/>
Las <code>fracciones</code> y <code>colores</code> son vectores de la misma dimensión conteniendo las longitudes ponderadas de cada patrón de color.<br/>
El <code>ciclo</code> repite, refleja, o ninguna de las dos, el patrón.<br/>
La <code>matriz</code> aplica una matriz de transformación al patrón (por defecto la identidad).
</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_gradiente.png" class="centerImg"/>
	<figcaption><br/><code>gradiente inicio &lt;posición> final &lt;posición> [radio &lt;radio>] fracciones &lt;fracciones> colores &lt;colores> [ciclo &lt;ciclo>] [matriz &lt;matriz>]</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de gradiente</figcaption>
	<img src="images_jmes/ctx2d_gradiente_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/ctx2d_gradiente_resultado.png" class="centerImg"/>
</figure>
<br/>
</section>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_trazo">+ Cláusula <ins>trazo</ins></h3>
<br/>
<div class="content">
	<p>Establece el grosor y tipo de trazo de las líneas en las formas geométricas.</p>
	<p>Nota: el grosor se ve afectado por la escala de la matriz de transformación.</p>
	<p>Si no se establece un determinado parámetro, se mantiene el valor previo, excepto si sólo se especifica grosor, que establece a <code>'redondo'</code>
	los extremos y uniones y elimina el rayado (el rayado también se elimina con <code>[0]</code>).</p>
	<p>Los valores <code>otro1, otro2, otro3</code> permiten ampliar la implementación estándar (no tienen efecto en <i>JMEScriptGUI</i>).</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span><br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_trazo.png" class="centerImg"/>
	<figcaption><br/><code>trazo grosor &lt;grosor> [extremo &lt;extremo>] [union &lt;union>] [inglete &lt;inglete>] [raya &lt;raya] [fase &lt;fase>]</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de distintos trazos</figcaption>
	<img src="images_jmes/ctx2d_trazo_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/ctx2d_trazo_ejecucion_ejemplo.png" class="centerImg"/>
</figure>
<br/>
</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_punto">+ Cláusula <ins>punto</ins></h3>
<br/>
<div class="content">
	<p>Dibuja un punto en el lienzo.</p>
	<p>Cuatro tipos de puntos pueden dibujarse en la implementación estándar; <code>pixel, rombo, cruz, mira</code>.
	El valor por defecto es <code>pixel</code>.</p>
	<p>Los valores <code>otro1, otro2, otro3</code> permiten ampliar la implementación estándard (no tienen efecto en <i>JMEScriptGUI</i>).</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_punto.png" class="centerImg"/>
	<figcaption><br/><code>punto &lt;posicion> [tipo &lt;tipo>]</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de 4 tipos de puntos</figcaption>
	<img src="images_jmes/ctx2d_punto_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/ctx2d_punto_ejecucion_ejemplo.png" class="centerImg"/>
</figure>
<br/>
</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_segmento">+ Cláusula <ins>segmento</ins></h3>
<br/>
<div class="content">
	<p>Dibuja un segmento en el lienzo.</p>
	<p>Los parámetros <code>inicio</code> y <code>final</code> determinan los extremos del segmento.</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span><br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_segmento.png" class="centerImg"/>
	<figcaption><br/><code>segmento inicio &lt;extremo> final &lt;extremo></code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de cláusula <b>segmento</b></figcaption>
	<img src="images_jmes/ctx2d_segmento_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/ctx2d_segmento_ejecucion_ejemplo.png" class="centerImg"/>
</figure>
<br/>
</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_rectangulo">+ Cláusula <ins>rectangulo</ins></h3>
<br/>
<div class="content">
	<p>Dibuja un rectángulo en el lienzo.</p>
	<p>Los parámetros <code>inicio</code> y <code>final</code> determinan las esquinas superior izquierda e inferior derecha respectivamente.
	   El parámetro <code>esquina</code> acepta un vector <code>[semiejeX,semiejeY]</code> que permite definir bordes redondeados.
	   <code>relleno</code> y <code>borde</code> son flags que indican si se dibuja el interior y la frontera del rectángulo 
	   respectivamente (por defecto, <code>borde</code> es <i>verdadero</i> si no se especifica <code>relleno</code>).
	   <code>3d</code> indica el tipo de de relieve (<i>resaltado</i>, <i>grabado</i> o <i>ninguno (defecto)</i>).
	   Los valores <code>otro1, otro2, otro3</code> permiten ampliar la implementación estándar (no tienen efecto en <i>JMEScriptGUI</i>). 
	</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span><br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_rectangulo.png" class="centerImg"/>
	<figcaption><br/><code>rectangulo inicio &lt;esquina_sup_izq> final &lt;esquina_inf_der> [esquina &lt;radio_esquinas>]
				[relleno &lt;relleno>] [borde &lt;borde>] [3d &lt;resaltado>]</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de cláusula <b>rectangulo</b></figcaption>
	<img src="images_jmes/ctx2d_rectangulo_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/ctx2d_rectangulo_ejecucion_ejemplo.png" class="centerImg"/>
</figure>
<br/>
</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_circunferencia">+ Cláusula <ins>circunferencia</ins></h3>
<br/>
<div class="content">
	<p>Dibuja una circunferencia, círculo o arco en el lienzo.</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span><br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_circunferencia.png" class="centerImg"/>
	<figcaption><br/><code>circunferencia centro &lt;centro> radio &lt;radio> [angulo &lt;angulo_ini>] 
				[arco &lt;long_arco>] [cierre &lt;tipo_cierre>] [relleno &lt;relleno>] [borde &lt;borde>]</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de cláusula <b>circunferencia</b></figcaption>
	<img src="images_jmes/ctx2d_circunferencia_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/ctx2d_circunferencia_ejecucion_ejemplo.png" class="centerImg"/>
</figure>
<br/>
</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_elipse">+ Cláusula <ins>elipse</ins></h3>
<br/>
<div class="content">
	<p>Dibuja una elipse en el lienzo.</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span><br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_elipse.png" class="centerImg"/>
	<figcaption><br/><code>elipse inicio &lt;esquina_sup_izq> final &lt;esquina_inf_der> [relleno &lt;relleno>] [borde &lt;borde>]</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de cláusula <b>elipse</b></figcaption>
	<img src="images_jmes/ctx2d_elipse_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/ctx2d_elipse_ejecucion_ejemplo.png" class="centerImg"/>
</figure>
<br/>
</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_poligono">+ Cláusula <ins>poligono</ins></h3>
<br/>
<div class="content">
	<p>Dibuja un polígono en el lienzo.</p>
	<p>Las coordenadas se introducen mediante un vector de coordenadas X y un vector Y (de la misma dimensión).</p>
	<p>La cláusula <i><b>cerrar</b></i> a <i>falso</i> permite dejar abierto el polígono en los extremos <small>(defecto <i>verdadero</i>)</small>. 
<hr/>
<span class="subSimple">Diagrama sintáctico:</span><br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_poligono.png" class="centerImg"/>
	<figcaption><code>poligono coordx &lt;coordx> coordy &lt;coordy> [cerrar &lt;cerrar>] [relleno &lt;relleno>] [borde &lt;borde>]</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de cláusula <b>poligono</b></figcaption>
	<img src="images_jmes/ctx2d_poligono_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/ctx2d_poligono_ejecucion_ejemplo.png" class="centerImg"/>
</figure>
<br/>
</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_ruta">+ Cláusula <ins>ruta</ins></h3>
<br/>
<section class="content">
	<p>Dibuja una ruta genérica en el lienzo a partir de diferentes acciones.</p>
	<p>La ruta se establece mediante una matriz <code>nx2</code> en que cada fila especifica la acción y un vector de puntos 2D:<br/>
	<code>&emsp;| &lt;acción1> &lt;puntos1> |<br/>
	&emsp;| &lt;acción2> &lt;puntos2> |<br/>
	&emsp;| &lt;acción3> &lt;puntos3> |<br/>
	&emsp;&emsp;&emsp;&emsp;&hellip;<br/>
	&emsp;| &lt;acciónN> &lt;puntosN> |<br/></code>
	</p> 
	<p>Las acciones y puntos se especifican mediante:</p>
	<ul>
		<li><b>'mover_a'</b>: y el punto al que se desplaza el pincel sin dibujar en forma de matriz <code>[[x<sub>1</sub>,y<sub>1</sub>]]</code></li>
		<li><b>'linea_a'</b>: y el punto al que se desplaza el pincel dibujando una línea en forma de matriz <code>[[x<sub>1</sub>,y<sub>1</sub>]]</code></li>
		<li><b>'cuad_a'</b>: y los dos puntos que completan la curva de tres puntos en forma de matriz <code>[[x<sub>1</sub>,y<sub>1</sub>],[x<sub>2</sub>,y<sub>2</sub>]]</code></li>
		<li><b>'curva_a'</b>: y los tres puntos que completan la curva de cuatro puntos en forma de matriz <code>[[x<sub>1</sub>,y<sub>1</sub>],[x<sub>2</sub>,y<sub>2</sub>],[x<sub>3</sub>,y<sub>3</sub>]]</code></li>
		<li><b>'cerrar'</b>: cierra la curva si es cerrada especificando un vector vacío</li>
	</ul>
	<p><code>regla</code> especifica la regla de determinación del interior <i>(winding-rules)</i>, sus valores son <b>'no_cero'</b> o <b>'par_impar'</b> (por defecto)</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span><br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_ruta.png" class="centerImg"/>
	<figcaption><br/><code>ruta &lt;matriz-acciones> [regla &lt;regla>] [relleno &lt;relleno>] [borde &lt;borde>]</code></figcaption>
</figure>
<hr/>
<figure style="margin:auto;">
	<figcaption style="caption-side: top">Ejemplo de cláusula <b>ruta</b></figcaption>
	<img src="images_jmes/ctx2d_ruta_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin:auto;">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/ctx2d_ruta_resultado.png" class="centerImg"/>
</figure>
<br/>
</section>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_texto">+ Cláusula <ins>texto</ins></h3>
<br/>
<div class="content">
	<p>Dibuja y mide texto en el lienzo.</p>
	<p>El parámetro <code>dimension en</code> devuelve un vector <code>[ancho,alto]</code> con el tamaño del texto en la variable especificada.</p>
	<p>Si no se especifica un parámetro relativo a la fuente, se mantiene el actual.</p>
	<p>La cláusula <b>estilo</b> toma los valores <span class="monospace">plano, negrita, cursiva, neg_cur</span>. Los valores
	<span class="monospace">otro1, otro2, otro3</span> permiten ampliar la implementación estándar (no tienen efecto en <i>JMEScriptGUI</i>).</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span><br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_texto.png" class="centerImg"/>
	<figcaption><br/><code>texto [posicion &lt;posicion>]|[dimension en &lt;varname>] [tama &lt;tamaño>] [familia &lt;familia>] [estilo &lt;estilo>]</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de cláusula 'texto'</figcaption>
	<img src="images_jmes/ctx2d_texto_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/ctx2d_texto_ejecucion_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de sombreado</figcaption>
	<img src="images_jmes/ctx2d_texto_ejemplo2.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/texto_sombra.gif" class="centerImg"/>
</figure>
<br/>
</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_repintar">+ Cláusula <ins>repintar</ins></h3>
<br/>
<div class="content">
	<p>Redibuja el lienzo con los últimos cambios</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span><br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_repintar.png" class="centerImg"/>
	<figcaption><br/><code>repintar</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de cláusula 'repintar'</figcaption>
	<img src="images_jmes/ctx2d_repintar_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/repintar.gif" class="centerImg"/>
</figure>
<br/>
</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_limpiar">+ Cláusula <ins>limpiar</ins></h3>
<br/>
<div class="content">
	<p>Borra el lienzo o una parte de él con el color de fondo o el color especificado.</p>
	<p>Si no se especifica el color se tomará el color de fondo.</p>
	<p>Si no se especifica la posición inicial y final, se limpia todo el lienzo.</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span><br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_limpiar.png" class="centerImg"/>
	<figcaption><br/><code>limpiar [inicio &lt;posicion> final &lt;posicion>] [color &lt;color>]</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de cláusula 'limpiar'</figcaption>
	<img src="images_jmes/ctx2d_limpiar_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/limpiar.gif" class="centerImg"/>
</figure>
<br/>
</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_matriz">+ Cláusula <ins>matriz</ins></h3>
<br/>
<section class="content">
	<p>Establece la matriz de transformación del lienzo u obtiene la actual matriz del lienzo en formato de vector de 6 elementos.</p>
	<p>La matriz puede establecerse de cuatro formas:</p>
	<ul>
		<li>matriz normalizada de 3x3:<br/>
			<code style="white-space: pre">
	| sx  shx tx |
	| shy  sy ty |
	| 0   0   1  |
			</code>
		</li>
		<li>matriz 2x3:<br/>
			<code style="white-space: pre">	
	| sx  shx tx |
	| shy  sy ty |
			</code>
		</li>
		<li>vector de 4 elementos (sin traslación):<br/>
			<code style="white-space: pre">	
	[ sx shy shx sy ]
			</code>
		</li>
		<li>vector de 6 elementos:<br/>
			<code style="white-space: pre">
	[ sx shy shx sy tx ty ]
			</code>
		</li>
	</ul>
	<p>Si se añade el modificador *, la matriz especificada se premultiplicará a la actual</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span><br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_matriz.png" class="centerImg"/>
	<figcaption><br/><code>{matriz|matriz* &lt;matriz>|&lt;vector>}|{matriz en &lt;varname>}</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de cláusula 'matriz'</figcaption>
	<img src="images_jmes/ctx2d_matriz_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/ctx2d_matriz_resultado.png" class="centerImg"/>
</figure>
<br/>
</section>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_entorno">+ Cláusula <ins>entorno</ins></h3>
<br/>
<div class="content">
	<p>Devuelve un diccionario con información del sistema, del lienzo, del lenguaje JMEScript y el parser JME
	(no es necesario que el lienzo esté inicializado)</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span><br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_entorno.png" class="centerImg"/>
	<figcaption><code>entorno en &lt;varname></code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de cláusula 'entorno'</figcaption>
	<img src="images_jmes/ctx2d_entorno_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<p class="content">
<span class="subSimple">Salida en consola:</span>
</p>
<div class="content console">
<p class="javaOutput">
 {                    'jme.lib_name': 'JME'
                       'jme.version': '0.6.2.0'
               'jmescript.lang_name': 'JMEScript'
                 'jmescript.version': '0.2.0'
                           'ui.name': 'JMEScriptGUI'
                   'ui.version_name': ''
                        'ui.version': '0.1.2.0'
              'prim2d.lib_name.name': 'JMEScriptGUI Primitivas2D'
      'prim2d.lib_name.version_name': 'Viviana para JMEScriptGUI'
           'prim2d.lib_name.version': '0.1.0'
               'lienzo.inicializado': falso
                      'lienzo.ancho': -1
                       'lienzo.alto': -1
                'lienzo.color.linea': [0,0,0,255]
              'lienzo.color.relleno': [0,0,0,255]
                'lienzo.color.fondo': [0,0,0,255]
                    'pantalla.ancho': 1920
                     'pantalla.alto': 1080
                          'user.dir': 'C:\<mark class="gray1">(...)</mark>'
                         'user.home': 'C:\<mark class="gray1">(...)</mark>'
                         'user.name': 'M<mark class="gray1">(...)</mark>'
                       'java.vendor': 'Oracle Corporation'
                 'sun.java.launcher': 'SUN_STANDARD'
              'NUMBER_OF_PROCESSORS': '8'
           'sun.management.compiler': 'HotSpot 64-Bit Tiered Compilers'
   'FPS_BROWSER_USER_PROFILE_STRING': 'Default'
                           'os.name': '<mark class="gray1">(...)</mark>'
                        'RegionCode': 'EMEA'
               'sun.boot.class.path': 'C:\<mark class="gray1">(...)</mark>'
                           'PATHEXT': '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC'
                       'sun.desktop': '<mark class="gray1">(...)</mark>'
      'java.vm.specification.vendor': 'Oracle Corporation'
                              'TEMP': 'C:\<mark class="gray1">(...)</mark>'
              'java.runtime.version': '<mark class="gray1">(...)</mark>'
    'FPS_BROWSER_APP_PROFILE_STRING': '<mark class="gray1">(...)</mark>'
                'CommonProgramW6432': 'C:\<mark class="gray1">(...)</mark>'
                      'ProgramFiles': 'C:\<mark class="gray1">(...)</mark>'
                    'OnlineServices': 'Online Services'
                     'user.language': 'es'
                          'OneDrive': 'C:\<mark class="gray1">(...)</mark>'
             'sun.boot.library.path': 'C:\<mark class="gray1">(...)</mark>'
                      'LOCALAPPDATA': 'C:\<mark class="gray1">(...)</mark>'
                      'java.version': '1<mark class="gray1">(...)</mark>'
                   'PROCESSOR_LEVEL': '6'
                     'user.timezone': 'Europe/Paris'
                          'USERNAME': 'M<mark class="gray1">(...)</mark>'
               'sun.arch.data.model': '64'
                'java.endorsed.dirs': 'C:\<mark class="gray1">(...)</mark>'
                   'sun.cpu.isalist': '<mark class="gray1">(...)</mark>'
                  'sun.jnu.encoding': 'Cp1252'
                 'file.encoding.pkg': 'sun.io'
                         'HOMEDRIVE': 'C:'
                    'file.separator': '\'
           'java.specification.name': 'Java Platform API Specification'
                               '=::': '::\'
                'java.class.version': '52.0'
                      'user.country': 'ES'
                   'ALLUSERSPROFILE': 'C:\<mark class="gray1">(...)</mark>'
                         'java.home': 'C:\<mark class="gray1">(...)</mark>'
                      'java.vm.info': 'mixed mode'
                        'os.version': '<mark class="gray1">(...)</mark>'
                      'platformcode': 'KV'
                               'TMP': 'C:\<mark class="gray1">(...)</mark>'
                    'path.separator': ';'
                   'java.vm.version': '2<mark class="gray1">(...)</mark>'
                      'user.variant': ''
           'CommonProgramFiles(x86)': 'C:\<mark class="gray1">(...)</mark>'
   'sun.awt.enableExtraMouseButtons': 'true'
         'USERDOMAIN_ROAMINGPROFILE': 'H<mark class="gray1">(...)</mark>'
               'java.awt.printerjob': 'sun.awt.windows.WPrinterJob'
                'CommonProgramFiles': 'C:\<mark class="gray1">(...)</mark>'
           'sun.io.unicode.encoding': 'UnicodeLittle'
                           'ComSpec': 'C:\<mark class="gray1">(...)</mark>'
                          'HOMEPATH': '\<mark class="gray1">(...)</mark>'
                       'awt.toolkit': 'sun.awt.windows.WToolkit'
                      'COMPUTERNAME': 'H<mark class="gray1">(...)</mark>'
                       'user.script': ''
             'VBOX_MSI_INSTALL_PATH': 'C:\<mark class="gray1">(...)</mark>'
                            'PUBLIC': 'C:\<mark class="gray1">(...)</mark>'
                       'ProgramData': 'C:\<mark class="gray1">(...)</mark>'
         'java.specification.vendor': 'Oracle Corporation'
                       'USERPROFILE': 'C:\<mark class="gray1">(...)</mark>'
                 'java.library.path': 'C:\<mark class="gray1">(...)</mark>'
                   'java.vendor.url': 'http://java.oracle.com/'
                           'APPDATA': 'C:\<mark class="gray1">(...)</mark>'
                    'java.vm.vendor': 'Oracle Corporation'
                 'java.runtime.name': 'Java(TM) SE Runtime Environment'
                  'sun.java.command': 'jmescriptgui.Launcher'
                   'java.class.path': 'C:\<mark class="gray1">(...)</mark>'
                              'Path': 'C:/<mark class="gray1">(...)</mark>'
        'java.vm.specification.name': 'Java Virtual Machine Specification'
            'PROCESSOR_ARCHITECTURE': '<mark class="gray1">(...)</mark>'
              'PROCESSOR_IDENTIFIER': '<mark class="gray1">(...)</mark>'
                       'SESSIONNAME': 'Console'
     'java.vm.specification.version': '1.8'
                    'sun.cpu.endian': 'little'
                'sun.os.patch.level': ''
                                'OS': '<mark class="gray1">(...)</mark>'
                    'java.io.tmpdir': 'C:\<mark class="gray1">(...)</mark>'
                 'ProgramFiles(x86)': 'C:\<mark class="gray1">(...)</mark>'
               'java.vendor.url.bug': 'http://bugreport.sun.com/bugreport/'
                        'SystemRoot': 'C:\<mark class="gray1">(...)</mark>'
                           'os.arch': '<mark class="gray1">(...)</mark>'
              'java.awt.graphicsenv': 'sun.awt.Win32GraphicsEnvironment'
                     'java.ext.dirs': 'C:\<mark class="gray1">(...)</mark>'
                       'LOGONSERVER': '\<mark class="gray1">(...)</mark>'
                        'USERDOMAIN': 'H<mark class="gray1">(...)</mark>'
                    'line.separator': '
'
                      'java.vm.name': 'Java HotSpot(TM) 64-Bit Server VM'
                'PROCESSOR_REVISION': '8e0a'
                      'ProgramW6432': 'C:\<mark class="gray1">(...)</mark>'
                            'windir': 'C:\<mark class="gray1">(...)</mark>'
                     'file.encoding': 'Cp1252'
                       'SystemDrive': 'C:'
        'java.specification.version': '1.8'
                      'PSModulePath': 'C:\<mark class="gray1">(...)</mark>'
                        'DriverData': 'C:\<mark class="gray1">(...)</mark>' }
</p>
</div>
</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_click">+ Cláusula <ins>click</ins></h3>
<br/>
<div class="content">
	<p>Captura eventos de ratón, touchpad, toque en pantalla,&hellip;.
	<br/>También permite ignorar todos los eventos encolados en ese momento o parte de ellos.</p>
	<p>El valor almacenado en la variable es un diccionario con la información del evento de ratón:</p>
	<ul>
		<li><b>id</b>: tipo de evento; <code>[PRESSED, RELEASED, CLICKED, MOVED, DRAGGED, ENTERED, EXITED, WHEEL, OTRO1, OTRO2, OTRO3]</code></li>
		<li><b>boton</b>: nº de botón; <code>[BOTON1, BOTON2, BOTON3, NO_BOTON, OTRO1, OTRO2, OTRO3]</code></li>
		<li><b>clicks</b>: nº de clicks</li>
		<li><b>posicion</b>: vector bidimensional con la posición en el lienzo (no tiene en cuenta transformaciones)</li>
		<li><b>posicion_en_pantalla</b>: vector bidimensional con la posición respecto al dispositivo</li>
		<li><b>timestamp</b>: marca de tiempo del evento</li>
		<li><b>rotaciones</b>: rotaciones de la rueda (positivas o negativas), solo para evento <code>WHEEL</code></li>
	</ul>
	<p>Si no hay ningún evento, la variable queda <b><i>indefinida</i></b>.</p>
	<p>La cláusula <b>consumir</b> elimina todos los eventos actuales o si se especifica un número de no descartados, 
	elimina todos los eventos excepto los especificados.<br/>
	<b><i>consumir 1</i></b> mantiene el último evento, <b><i>consumir 0</i></b> es igual a <b><i>consumir</i></b>.</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span><br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_click.png" class="centerImg"/>
	<figcaption><code>click [en &lt;varname>]|[consumir [&lt;eventos>]]</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Snippet de cláusula 'click' del script <code>garabatos.jmes</code></figcaption>
	<img src="images_jmes/ctx2d_click_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/click.gif" class="centerImg"/>
</figure>
<p class="content" style="font-size: 1.5em">
	<a href="scripts/garabatos.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/garabatos.jmes"><b>garabatos.jmes</b></a>
</p>
<p class="content" style="font-size: 1.5em">
	<a href="scripts/aguanta.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/aguanta.jmes"><b>aguanta.jmes</b></a>
</p>
<br/>
</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_pulsacion">+ Cláusula <ins>pulsacion</ins></h3>
<br/>
<div class="content">
	<p>Captura eventos de teclado.
	<br/>También permite ignorar todos los eventos encolados en ese momento o parte de ellos.</p>
	<p>El valor almacenado en la variable es un diccionario con la información del evento de teclado:</p>
	<ul>
		<li><b>keycode</b>: código asociado al evento</li>
		<li><b>modifiers</b>: modificadores del evento;
			<table border="1" style="margin: 5px 0px 5px 20px;text-align: center">
				<tr><th>Valor</th><th>Constante Java</th><th>Constante JME</th></tr>
				<tr><td>64</td><td><code>AbstractKeyStroke.SHIFT</code></td><td><code><b>_shift_</b></code></td></tr>
				<tr><td>128</td><td><code>AbstractKeyStroke.CONTROL</code></td><td><code><b>_control_</b></code></td></tr>
				<tr><td>256</td><td><code>AbstractKeyStroke.META</code></td><td><code><b>_meta_</b></code></td></tr>
				<tr><td>512</td><td><code>AbstractKeyStroke.ALT</code></td><td><code><b>_alt_</b></code></td></tr>
				<tr><td>1024</td><td><code>AbstractKeyStroke.BUTTON1</code></td><td><code><b>_button1_</b></code></td></tr>
				<tr><td>2048</td><td><code>AbstractKeyStroke.BUTTON2</code></td><td><code><b>_button2_</b></code></td></tr>
				<tr><td>4096</td><td><code>AbstractKeyStroke.BUTTON3</code></td><td><code><b>_button3_</b></code></td></tr>
				<tr><td>8192</td><td><code>AbstractKeyStroke.ALT_GRAPH</code></td><td><code><b>_alt_graph_</b></code></td></tr>
				<tfoot>
					<tr><td colspan="3">&emsp;<i>Ejemplo, comprobar mayúsculas y alt;</i>&emsp;<b><code>tecla;#;'modifiers' = (_shift_|_alt_)</code></b></td></tr>
				</tfoot>
			</table>
		</li>
		<li><b>modifierstext</b>: descripción textual de los modificadores.
			<font color='red'><small>Nota: esta representación es dependiente de la plataforma y el idioma, y no debería usarse
			para controlar el flujo del script</small></font></li>
		<li><b>keychar</b>: Carácter Unicode asociado al evento (puede estar indefinido)</li>
		<li><b>iskeyreleased</b>: <i>verdadero</i> si el evento ocurre al soltar</li>
		<li><b>timestamp</b>: marca de tiempo del evento</li>
		<li><b>esaccion</b>: <i>verdadero</i> si es evento de acción (SHIFT, CONTROL, NUMPAD,&hellip;)</li>
		<li><b>localizacion</b>: localización para teclas dobles; <code>[ESTANDAR,DERECHA,IZQUIERDA,NUMPAD,DESCONOCIDA]</code></li>
	</ul>
	<p>Si no hay ningún evento, la variable queda <b><i>indefinida</i></b>.</p>
	<p>La cláusula <b>consumir</b> elimina todos los eventos actuales o si se especifica un número de no descartados, 
	elimina todos los eventos excepto los especificados.<br/>
	<b><i>consumir 1</i></b> mantiene el último evento, <b><i>consumir 0</i></b> es igual a <b><i>consumir</i></b>.</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span><br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_pulsacion.png" class="centerImg"/>
	<figcaption><br/><code>pulsacion [en &lt;varname>]|[consumir [&lt;eventos>]]</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Snippet de cláusula 'pulsacion' del script <code>2048.jmes</code></figcaption>
	<img src="images_jmes/ctx2d_pulsacion_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/2048.gif" class="centerImg"/>
</figure>
<p class="content" style="font-size: 1.5em">
	<a href="scripts/2048.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/2048.jmes"><b>2048.jmes</b></a>
</p>
<p class="content" style="font-size: 1.5em">
	<a href="scripts/lector_pulsaciones.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/lector_pulsaciones.jmes"><b>lector_pulsaciones.jmes</b></a>
</p>
<br/>
</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_msj">+ Cláusula <ins>msj</ins></h3>
<br/>
<section class="content">
<p>Muestra mensajes al usuario por el intefaz gráfico.</p>
<p>Los mensajes <b><i>toast</i></b> se mostrarán el tiempo especificado en milisegundos.</p>
<p>En <i>JMEScriptGUI</i>, los tipos <code>debug</code> y <code>confirm</code> son idénticos a <code>info</code> y <code>ok</code>
sólo está disponible para <i>toast</i>, en caso contrario también es idéntico a <code>info</code>. El tipo por defecto es <code>info</code>.
La posición sólo está disponible para <i>toast</i>, si no se especifica, aparece centrado-abajo. Los tipos <code>otro1</code>, <code>otro2</code> y
<code>otro3</code> no forman parte del estándar y permiten ampliar la funcionalidad.</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span><br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_msj.png" class="centerImg"/>
	<figcaption><br/><code>msj &lt;msj> [tipo &lt;tipo>] [posicion &lt;posición>] [toast &lt;tiempo>]</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de cláusula 'msj'</figcaption>
	<img src="images_jmes/ctx2d_msj_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/ctx2d_msj_resultado.gif" class="centerImg"/>
</figure>
<br/>
</section>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_leer">+ Cláusula <ins>leer</ins></h3>
<br/>
<section class="content">
<p>Permite al usuario introducir información a través del interfaz gráfico.</p>
<ul>
	<li>tipo <code>booleano</code>; hace una pregunta SI/NO y devuelve <i>Booleano</i>,</li>
	<li>tipo <code>texto</code>; lee un texto y devuelve <i>Texto</i>,</li>
	<li>tipo <code>expresion</code>; lee una expresión JME, la evalúa con las variables actuales del script y devuelve el resultado,</li>
	<li>tipo <code>opciones</code>; ofrece un grupo de opciones y devuelve la escogida como <i>Texto</i></li>
</ul>
<p>Los tipos <code>otro1</code>, <code>otro2</code> y <code>otro3</code> no forman parte del estándar y permiten ampliar la funcionalidad.</p>
<p>Si la entrada de datos se cancela, se obtiene la constante de error <b>__error1__</b>. Si se produce un error, se obtiene la constante
<b>__error2__</b> (véase ejemplo).</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span><br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_leer.png" class="centerImg"/>
	<figcaption><br/><code>leer en &lt;varname> [tipo &lt;tipo>] [opciones &lt;opciones>] [msj &lt;mensaje>]</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de cláusula 'leer'</figcaption>
	<img src="images_jmes/ctx2d_leer_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/ctx2d_leer_resultado.gif" class="centerImg"/>
</figure>
<br/>
</section>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_archivo">+ Cláusula <ins>archivo</ins></h3>
<br/>
<div class="content">
	<p>Muestra un diálogo del sistema de archivos para la selección de uno o varios archivos/directorios.</p>
	<p>Si no se especifica la ruta se toma la ruta por defecto del sistema. Si se usa la cadena vacía, la ruta de la última ejecución (si la hay).</p>
	<p>El valor devuelto es un vector con las rutas de los archivos/directorios seleccionados. Si se cancela o no se selecciona ninguno, devuelve un vector vacío.</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span><br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/ctx2d_archivo.png" class="centerImg"/>
	<figcaption><br/><code>archivo en &lt;varname> [ruta &lt;ruta>] [titulo &lt;titulo>]</code></figcaption>
</figure>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de cláusula 'archivo'</figcaption>
	<img src="images_jmes/ctx2d_archivo_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI (escritorio)</figcaption>
	<img src="images_jmes/archivo.gif" class="centerImg"/>
</figure>
<br/>
</div>

</div>

<!-- SQL  -->
<br/><br/>
<h3 class="subSection" id="sql">Sentencia de acceso a SGBDR</h3>
<br/>
<p class="content">
Permite conectar a una base de datos, cerrarla, acceder a la información y modificar datos. 
</p>
<p class="content">
Para ejecutar esta sentencia debe estar definido un SGBDR en el sistema que permita ejecutar todas sus primitivas mediante <i>JMEScript</i>.
En <b class="small"><a href="jmescriptgui.html" class="discLink" style="color: #335">JMEScriptGUI</a></b> para escritorio pueden ejecutarse 
todas las primitivas usando MySQL y el Conector-J. En el apartado para desarrolladores se explica como implementar un interfaz de conexión entre la base de datos y <i>JMEScript</i> 
a partir de la clase <code>AbstractSql</code>. 
</p>
<hr class="content"/>
<p class="content">
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/sql.png" class="centerImg"/>
	<br/><figcaption><code>sql [# &lt;indice> #] &lt;claúsula_sql></code></figcaption>
</figure>
<br/>
<hr class="content"/>

<p class="content">
El índice del SGBDR por defecto es 1, e indica el SGBDR a utilizar en caso de múltiples gestores.
</p>

<hr class="content">
<p class="content" style="font-size: 1.5em">
	<a href="scripts/sql_visor.jmes" download><img src="images_jmes/download.png"/></a>
	<a class="discLink monospace" href="scripts/sql_visor.jmes"><b>sql_visor.jmes</b></a>
</p>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo completo: visor SQL para la lectura secuencial de consultas</figcaption>
	<img src="images_jmes/sql_visor_script.gif" class="centerImg"/>
</figure>

<div class="content">

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_conectar">+ Cláusula <ins>conectar</ins></h3>
<br/>
<div class="content">
<p>La cláusula <i>conectar</i> permite especificar el <b>host</b>, <b>usuario</b> (si existe), y <b>clave</b> (si existe) de la conexión a la BD,
además de asignarle un identificador (puede ser cualquier valor JME).
</p>
<p><br/>El valor almacenado en la variable de la subcláusula <b>exito en</b> es <b>verdadero</b> 
si la conexión es correcta, si no lo es, se almacena un <b>texto con el mensaje de error</b></p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/sql_conectar.png" class="centerImg"/>
	<br/><figcaption><code>conectar exito en &lt;varname> id &lt;id_conexión> host &lt;host> [usuario &lt;user>] [clave &lt;password>]</code></figcaption>
</figure>
<br/>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de cláusula 'conectar'</figcaption>
	<img src="images_jmes/sql_conectar_ejemplo.png" class="centerImg"/>
</figure>
<p><span class="subSimple">Salida en consola:</span></p>
<div class="console">
<p class="javaOutput">- host falso:  
'Communications link failure

The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.'  

- necesario usuario:  
'Access denied for user '[...]'@'[...]' (using password: NO)'  

- conexión válida:  
verdadero
</p>
</div>

</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_ejecutar">+ Cláusula <ins>ejecutar</ins></h3>
<br/>
<div class="content">
<p>La cláusula <i>ejecutar</i> efectúa una consulta contra la base de datos.</p>
<p><br/>La cláusula toma el identificador de la conexión en <b>id</b> y asigna un identificador de consulta en <b>sentencia</b> (cualquier valor JME).</p>
<p>El valor almacenado en la variable de la subcláusula <b>exito en</b> es un booleano si la consulta es correcta, 
si no lo es, se almacena un <b>texto con el mensaje de error</b>. El valor booleano es <code>verdadero</code> si la consulta
es de selección, y <code>falso</code> si es de acción</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/sql_ejecutar.png" class="centerImg"/>
	<br/><figcaption><code>ejecutar exito en &lt;varname> id &lt;id_conexión> sentencia &lt;id_sent> consulta &lt;consulta_sql></code></figcaption>
</figure>
<br/>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de cláusula 'ejecutar'</figcaption>
	<img src="images_jmes/sql_ejecutar_ejemplo.png" class="centerImg"/>
</figure>
<p><span class="subSimple">Salida en consola:</span></p>
<div class="console">
<p class="javaOutput">- consulta 1:  
falso  'consulta de acción'  

- consulta 2:  
verdadero  'consulta de selección'  

- consulta 3:  
'Table 'ej6_catastro_municipal.inexistente' doesn't exist'  

- consulta 4:  
'You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near 'desde vivienda' at line 1'  
</p>
</div>

</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_resultado">+ Cláusula <ins>resultado</ins></h3>
<br/>
<div class="content">
<p>La cláusula <i>resultado</i> lee secuencialmente los registros o número de actualizaciones de una consulta a partir del identificador de consulta.</p>
<p><br/>La cláusula toma el identificador de la conexión en <b>id</b> y el identificador de consulta en <b>sentencia</b>
de la sentencia <i>ejecutar</i>.</p>
<p>La subcláusula <b>columnas</b> permite especificar la columnas devueltas en una selección. Columnas individuales se especifican con el nombre
de la columna (ej. <code>'nombre'</code>), múltiples con un vector de columnas (ej. <code>['nombre','apellidos']</code>). 
Por defecto es <code>'*'</code>, que muestra todas las columnas especificadas en la consulta.</p>
<p>El valor almacenado en la variable de la subcláusula <b>registro en</b> es</p>
<ul>
	<li>un diccionario si la lectura de una consulta de selección es correcta,</li>
	<li>un entero si es una consulta de acción correcta,</li>
	<li>valor <i>nulo</i> si se ha terminado la lectura del conjunto de resultados,</li>
	<li>un texto distinto de <i>nulo</i> con el mensaje de error si ha ocurrido un error en la lectura</li>
</ul>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/sql_resultado.png" class="centerImg"/>
	<br/><figcaption><code>resultado id &lt;id_conexión> sentencia &lt;id_sent> [columnas &lt;columnas>] registro en &lt;varname></code></figcaption>
</figure>
<br/>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de cláusula 'resultado'</figcaption>
	<img src="images_jmes/sql_resultado_ejemplo.png" class="centerImg"/>
</figure>
<p><span class="subSimple">Salida en consola:</span></p>
<div class="console">
<p class="javaOutput"> {         'calle': 'Damasco'
          'numero': 20
   'tipo_vivienda': 'B'
   'codigo_postal': 14500
          'metros': 120
     'od_vivienda': 0
     'nombre_zona': 'SECTOR SUR' }

 {         'calle': 'Guerra'
          'numero': 2
   'tipo_vivienda': 'C'
   'codigo_postal': 14500
          'metros': 150
     'od_vivienda': 0
     'nombre_zona': 'SUBURBIO TERMINAL' }

 {         'calle': 'Urbanización las Lomas'
          'numero': 53
   'tipo_vivienda': 'C'
   'codigo_postal': 14009
          'metros': 250
     'od_vivienda': 0
     'nombre_zona': 'TRASIERRA' }

-- terminado --  
</p>
</div>

</div>

<br/>
<h3 class="subSection" style="opacity: 66%" id="clsl_cerrar">+ Cláusula <ins>cerrar</ins></h3>
<br/>
<section class="content">
<p>La cláusula <i>cerrar</i> cierra la conexión con la base de datos especificada por el identificador.</p>
<p>La subcláusula <b>exito en</b> permite almacenar en una variable el resultado de la operación; <b>verdadero</b> si la conexión
se cerró correctamente o un mensaje de error en caso contrario.</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/sql_cerrar.png" class="centerImg"/>
	<br/><figcaption><code>cerrar [exito en &lt;varname>] id &lt;id_conexión></code></figcaption>
</figure>
<br/>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de cláusula 'cerrar'</figcaption>
	<img src="images_jmes/sql_cerrar_ejemplo.png" class="centerImg"/>
</figure>
<p><span class="subSimple">Salida en consola:</span></p>
<div class="console">
<p class="javaOutput">'Cerrada conexión con1'</p>
</div>

</section>

<!-- ACCIONES  -->
<br/><br/>
<h3 class="subSection" id="accion">Acciones en el entorno de ejecución</h3>
<br/>
<section class="content">
<p>
La sentencia <b>accion</b> permite ejecutar acciones preprogramadas en la propia aplicación JAVA donde ejecuta el script de <i>JMEScript</i>. 
</p>
<p>Si la aplicación implementa el interfaz <code>AbstractAppAcciones</code> con un mapa de acciones definidas por su identificador <code>(String)</code>,
pueden ejecutarse esas acciones mediante esta sentencia, recibir parámetros y devolver un valor convertido a tipo JME. Esto aporta a la aplicación
mucho más que simplemente la creación de macroinstrucciones (MACROS), ya que incluye toda la funcionalidad del lenguaje <i>JMEScript</i>, y no sólo acciones
secuenciales predefinidas (similarmente a <i>VBA</i> en el paquete <i>Office</i>).
</p>
<p>En la sección de <a href="#accioncode">desarrolladores</a>, puede verse un ejemplo de implementación del interfaz <code>AbstractAppAcciones</code> usado por el IDE <i>JMEScriptGUI</i>.</p>
<p>Nota: existe otra forma de ejecución de operaciones de la aplicación y de la API de JAVA, en este caso funcional, mediante la función
<a href="../functions/java.html" class="discLink"><b>java</b></a>.</p>
<hr/>
<span class="subSimple">Diagrama sintáctico:</span>
<br/><br/>
<figure style="margin: auto">
	<img src="images_jmes/accion.png" class="centerImg"/>
	<figcaption><br/><code>accion &lt;accion_id> [params &lt;parámetros>] [retorno en &lt;varname>]</code></figcaption>
</figure>
<br/>
<hr/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Ejemplo de sentencia 'accion' en JMEScriptGUI</figcaption>
	<img src="images_jmes/accion_ejemplo.png" class="centerImg"/>
</figure>
<br/>
<figure style="margin: auto">
	<figcaption style="caption-side: top">Salida en JMEScriptGUI</figcaption>
	<img src="images_jmes/accion_resultado.gif" class="centerImg"/>
</figure>


</section>

</div>

</div> <!-- Sentencias -->

<!-- VARIABLES -->
<br/>
<h2 class="subtitle" id="vars">Variables en <i>JMEScript</i></h2><br/>

<div class="tema content">
<p class="content">
Las variables en <i>JMEScript</i> pueden almacenar cualquier tipo de terminal <i>JME</i> o estar
indefinidas. Su valor se puede cambiar por el de cualquier otro tipo al ser un lenguaje débilmente
tipado, o eliminarse y posteriormente asignar un nuevo valor. La función <i>JME</i> <a class="discLink" href="../functions/indefinido.html"><b>indefinido</b></a>
permite comprobar si la variable está definida o asignar un valor por defecto.
</p>
<p class="content">
El nombre de las variables, como cualquier identificador JME, debe estar formado por un carácter inicial que debe ser
una letra o _ , y seguido por cualquier número de carácteres alfanuméricos o _ . 
</p>
<p class="content">
Las variables son accesibles en todo el script a partir del punto en que se definen
(si son externas desde el principio) hasta el final del script, excepto dentro de las rutinas 'locales', 
a menos que se eliminen mediante los operadores <b>:=</b> y <b>:==</b> o la sentencia <b>limpiar</b>.  
</p>
<p class="content">
Existen por lo tanto dos <b>ámbitos</b> en las variables de <i>JMEScript</i>, el del programa principal y el 
de las rutinas 'locales' (no globales), que tienen su propio diccionario de variables. Las variables definidas en bloques o 
sentencias siguen siendo visibles posteriormente.
</p>

<br/><br/>
<h3 class="subSection" id="ext_vars">Variables externas</h3>
<br/>
<p class="content">
Los scripts pueden recibir datos a través de variables definidas externamente, y que son visibles en el script.
Esto convierte a un script <i>JMEScript</i> en una especie de función, capaz de recibir parámetros externos y
devolver un resultado.
</p>
<p class="content">
Las variables externas pueden definirse a través de JAVA si se está desarrolando una aplicación o a través de
la función <a class="discLink" href="../functions/script.html"><b>script</b></a>, que permite ejecutar un script dentro de <i>JME</i>. 
</p>
<hr class="content"/>
<p class="content">
Ejemplo de llamada sin variables externas al script '<i class="monospace">palindromo.jmes</i>' y ejemplo pasándole variable
externa '<i>text</i>':
</p>
<img class="content centerImg" src="images_jmes/ext_vars_sample.png"/>
<br/>
<p class="content">
<span class="subSimple">Salida en REPL:</span>
</p>
<div class="content console">
<p class="javaOutput">>>> <mark class="ok">script(archivotxt('palindromo.jmes'),dic([]))</mark>

	 ==> Texto: 'MEROL MUSPI ROLOD TIS TEMA RUTETCESNOC GNICSIPIDA TILE DES DOMSUIE ROPMET TNUDICNI TU EROBAL TE EROLOD ANGAM AUQILA TU MINE DA MINIM MAINEV SIUQ DURTSON NOITATICREXE OCMALLU SIROBAL ISIN TU DIUQILA XE AE IDOMMOC TAUQESNOC SIUQ ETUA ERUI TIREDNEHERPER NI ETATPULOV TILEV ESSE MULLIC EROLOD UE TAIGUF ALLUN RUTAIRAP RUETPECXE TNIS TACEACBO TATIDIPUC NON TNEDIORP TNUS NI APLUC IUQ AICIFFO TNURESED TILLOM MINA DI TSE MUROBAL'

	(parse: 543µs(4%) / eval: 14,3ms(96%) / total: 14,9ms)</p>
</div>
<br/><br/>
<p class="content">
<span class="subSimple">Salida en REPL:</span>
</p>
<div class="content console">
<p class="javaOutput">>>> <mark class="ok">script(archivotxt('palindromo.jmes'),dic('text','Hola Mundo'))</mark>

	 ==> Texto: 'ALOH ODNUM'

	(parse: 2,8ms(16%) / eval: 14,3ms(84%) / total: 17,1ms)</p>
</div>
</div>

<!-- COMENTARIOS -->
<br/><br/>
<h2 class="subtitle" id="comment">Comentarios, líneas en blanco y multilínea</h2><br/>

<div class="tema content">
<p class="content">
Los comentarios en <i>JMEScript</i> son comentarios de una línea que comienzan con el carácter <b class="larger">#</b>.<br/>
Pueden ir precedidos por espacios o ir al final de una sentencia, y al igual que las líneas en blanco, son ignorados por el proceso de compilación.
</p>
<p class="content">
	<img src="images_jmes/comentario_ejemplo.png" class="centerImg"/>
</p>
<p class="content">
Una sentencia <i>JMEScript</i> muy larga puede fragmentarse simplemente añadiendo&emsp;<b class="larger">&gt;</b>&emsp;al principio de la siguiente línea por
cualquier parte de la misma.
<p class="content">
	<img src="images_jmes/multilinea_ejemplo.png" class="centerImg"/>
</p>
</div>

<!--  DESARROLLADORES -->
<br/><br/>
<h2 class="subtitle" id="developers">JMEScript para Desarrolladores</h2><br/>

<div class="tema content">
<p class="content">
La clase <b class="monospace larger">jme.script.Script</b> es la clase principal de los scripts <i>JMEScript</i>.
Consta de dos constructores, uno para una cadena con el código fuente (con saltos de línea en cada instrucción),
y otro con las líneas del código fuente como array de cadenas:
</p>
<pre><code class="content java">	/**
	 * Compila script a partir de cadena de código fuente JMEScript
	 * 
	 * @param script código fuente
	 * @throws ScriptException error al compilar script
	 */
	public Script( String script ) throws ScriptException 
</code></pre>

<pre><code class="content java">	/**
	 * Compila script a partir de líneas del código fuente JMEScript
	 * 
	 * @param lineas array con las líneas del script
	 * @throws ScriptException error al compilar script
	 */
	public Script( String[] lineas ) throws ScriptException 
</code></pre>

<p class="content">
Los constructores de la clase <b>Script</b> compilan e inicializan el script (identifican las sentencias y parsean las expresiones JME).
</p>
<p class="content">
El script puede ser ejecutado con los métodos <b class="monospace">Script#ejecutar</b>, que ejecuta el script sin ninguna variable externa,
y <b class="monospace">Script#ejecutar( HashMap&lt;String,Token> varMapIni )</b> que permite inicializar con un mapa de variables externas.
</p>
<p class="content">
El script se puede ejecutar múltiples veces. Evitar compilar el mismo script más de una vez (por ejemplo en un bucle), ya que
compilar puede ser un proceso lento, y solo es necesario una vez.
</p>
<p class="content">
Si el script ha finalizado correctamente, puede obtenerse el resultado del script (si se ha especificado una instrucción <b>devolver</b>
con parámetro), mediante los métodos:
</p>
<ul class="content">
	<li><b class="monospace">Script#getUltimoResultado&nbsp;&nbsp;</b> <small>(devuelve <i>Terminal</i>)</small></li>
	<li><b class="monospace">Script#getUltimoResultadoNumero</b></li>
	<li><b class="monospace">Script#getUltimoResultadoVector</b></li>
	<li><b class="monospace">Script#getUltimoResultadoBooleano</b></li>
	<li><b class="monospace">Script#getUltimoResultadoDiccionario</b></li>
	<li><b class="monospace">Script#getUltimoResultadoTexto</b></li>
</ul>
<p class="content">
El resultado es de tipo <b>Terminal</b> o también puede ser <b>null</b> si el script no devuelve nada, o usa <b>devolver</b> sin parámetro, 
o no ha terminado correctamente.</p>
<p class="content">
El script puede detenerse cuando está ejecutando en un hilo separado (que sería la forma correcta de hacerlo, véase la sección para 
<b>ScriptThread</b>), llamando al método <b>Thread#interrupt()</b> del hilo. Esto devolverá un <b>ScriptException</b>.
</p>
<p class="content">
Puede comprobarse que un script ha terminado si se ejecuta en otro hilo comprobando que <b>Script#isTerminado</b> es verdadero o <b>Script#isInterrumpido</b> es verdadero.
</p>
<p class="content">
Los métodos <b class="monospace">Script#getScript</b> y <b class="monospace">Script#getLineas</b> permiten leer el código fuente original
del script (como cadena única o array de cadenas).
</p>
<p class="content">
El método estático <b class="monospace">Script#cargarScriptDesdeArchivo( String filename )</b> permite cargar las líneas del script desde
un archivo de texto, a partir de la ruta y nombre del archivo, que pueden pasarse al constructor.
</p>
<p class="content">
Los métodos <i>gettesr&amp;setters</i> <b class="monospace">Script#getEntrada</b>, <b class="monospace">Script#setEntrada</b>, <b class="monospace">Script#getSalida</b>
y <b class="monospace">Script#setSalida</b>, permiten establecer los stream de entrada y salida por consola, por defecto <i>System.in</i> y <i>System.out</i> (puede asignarse <i>null</i>). 
</p>
<br/>
<p class="content">Ejemplo de ejecución del siguiente script en Java:</p>

<p class="content">
	<img src="images_jmes/primos_gemelos.png" class="centerImg content" width="67%"/>
</p>

<div class="content console">
<pre><code class="java">// crear y compilar script
Script script = new Script( Script.cargarScriptDesdeArchivo( "./primos_gemelos.jmes" ) );

// crear mapa de variables externas
HashMap&lt;String,Token> vars = new HashMap&lt;>();
vars.put( "m", new RealDoble(1) );
vars.put( "n", new RealDoble(100) );

// ejecutar y resultado
System.out.println( script.ejecutar(vars).getUltimoResultadoDiccionario().toStringVertical( " ", ": " ) );

// modificar variables externas
vars.put( "m", new RealDoble(1001) );
vars.put( "n", new RealDoble(1100) );

// ejecutar y resultado
System.out.println( script.ejecutar(vars).getUltimoResultadoDiccionario().toStringVertical( " ", ": " ) );
</code></pre>
<p class="javaOutput"> {     'lista parejas': [[3,5],[5,7],[11,13],[17,19],[29,31],[41,43],[59,61],[71,73]]
             'parejas': 8
    'lista individual': [3,5,7,11,13,17,19,29,31,41,43,59,61,71,73]
      'primos gemelos': 15
   'aproximacion Brun': 1.330990365719087 }

 {     'lista parejas': [[1019,1021],[1031,1033],[1049,1051],[1061,1063],[1091,1093]]
             'parejas': 5
    'lista individual': [1019,1021,1031,1033,1049,1051,1061,1063,1091,1093]
      'primos gemelos': 10
   'aproximacion Brun': 0.009518280355144647 }
</p>
</div>

<br/><br/>
<h3 class="subSection" id="thread">Ejecución en hilo</h3>
<br/>
<p class="content">
Al ejecutar determinados scripts siempre existe la posibilidad de que generen un bucle extremadamente largo o infinito
(así como ciertas operaciones en <i>JME</i>). Por eso, la mejor forma de ejecutar cualquier script es usar un hilo.
Cargando el script en un hilo, éste puede detenerse mediante <b>Thread#interrupt</b>, lo que hará que el script intente
detenerse lo antes posible al detectar el hilo como interrumpido, lo que lanzará una excepción. Como se comentó en la sección
anterior, puede comprobarse que el script está interrumpido con <b>Script#isInterrumpido</b> (también se interrumpe por una 
excepción del propio script, no solo por una señal de interrupción).
</p>
<p class="content">
Puede realizarse espera activa comprobando si el hilo ha terminado o a sido interrumpido mediante instrucciones como<br/><br/>
<b class="monospace larger">while ( !(script.isTerminado() || script.isInterrumpido()) )  /* hacer cosas */;</b><br/><br/>
pero si no se están realizando acciones mientras se espera al resultado, es preferible usar <b>Thread#join</b>,
y evitar la espera activa.
</p>

<br/><br/>
<h3 class="subSection" id="scriptthread">Clase ScriptThread</h3>
<br/>
<p class="content">
Puede utilizarse cualquier tipo de hilo para lanzar un script <i>JMEScript</i> (en Java 8+, por ejemplo, un <i>FutureTask</i>
sería una buena opción), pero la clase <b>jme.script.ScriptThread</b> permite lanzar fácilmente un script, incluyendo la
posibilidad de un temporizador.
</p>
<p class="content">
<b>ScriptThread</b> incluye dos constructores, iniciando a partir de un script compilado y un mapa opcional de variables iniciales.
El segundo permite añadir el tiempo máximo aproximado de ejecución:
</p>
<pre><code class="content java">/**
 * Crea un hilo a partir del script y un mapa inicial de variables
 * sin limite de tiempo
 * 
 * @param script Script compilado
 * @param varMap mapa de variables iniciales o {@code null}
 */
public ScriptThread( Script script, 
		     HashMap&lt;String,Token> varMap )


/**
 * Crea un hilo a partir del script y un mapa inicial de variables
 * con el límite de tiempo especificado en milisegundos
 * 
 * @param script Script compilado
 * @param varMap mapa de variables iniciales o {@code null}
 * @param maxTiempo tiempo antes de parar el script en milisegundos
 */
public ScriptThread( Script script, 
		     HashMap&lt;String,Token> varMap,
		     long maxTiempo )
</code></pre>

<p class="content">
El método <b>ScriptThread#getScript</b> permite obtener la instancia del script, y <b>ScriptThread#getException</b> la excepción
producida en caso de error o interrupción.
</p>
<p class="content">
El método <b>ScriptThread#alTerminar</b> es una rutina vacía en la clase base que ejecuta al terminar el script haya excepción o no.
Puede reescribirse para ejecutar cualquier código que se desee al terminar (avisar al hilo principal, imprimir un mensaje,...).
</p>
<p class="content">
El método <b>ScripThread#startAndJoin</b>, lanza el hilo del script y realiza un '<i>join</i>' del hilo padre a la espera del resultado
y puede capturar una excepción de tipo <i>Throwable</i> (generalmente una <i>ScriptException</i>) en caso de error o interrupción.
</p>
<br/>
<p class="content">
Ejemplo de script con temporizador en 2 segundos:
</p>

<div class="console content">
<pre><code class="java">Script script = new Script(
		"mientras rand(-1)&lt;0.999 inicio:",
		"jme: dormir(1e7)",
		"imprimir randint(1,6),",
		"fin" );

ScriptThread scriptThread = new ScriptThread( script, null, 2000 ) {
	@Override
	public void alTerminar() 
	{
		if ( getScript().isTerminado() )
			System.out.println( "--- Script terminado ---" );
		else if ( getScript().isInterrumpido() )
			System.out.println( "--- Script interrumpido ---" );
	}
};
try
{
    scriptThread.startAndJoin();
}
catch ( Throwable e )
{
    System.err.println( e.getMessage() );
}
</code></pre>
<small style="color:yellow">Ejecución 1:</small><br/>
<p class="javaOutput">6  4  5  6  4  2  6  3  6  5  4  6  5  2  6  3  1  1  4  4  5  3  3  3  1  3  
4  3  2  2  4  2  2  1  4  1  3  2  4  5  2  2  5  5  4  5  6  4  6  2  5  4  
2  1  1  4  1  3  6  1  6  6  4  5  4  6  6  1  1  5  4  6  1  5  4  6  1  4  
2  2  5  2  1  4  2  3  2  4  3  1  5  6  2  4  --- Script terminado ---</p>
<br/><small style="color:yellow">Ejecución 2:</small><br/>
<p class="javaOutput">5  2  6  6  3  6  4  2  2  6  1  6  4  3  6  1  1  4  6  1  3  6  3  2  1  6  
4  1  2  5  4  3  1  1  3  1  1  3  2  1  4  3  5  4  2  5  3  6  3  3  3  2  
3  1  6  5  2  5  4  4  6  1  6  2  1  4  3  6  4  4  2  2  1  5  4  6  3  6  
2  5  3  4  4  4  4  5  4  3  2  6  6  2  4  1  3  1  4  1  3  5  4  1  3  2  
3  3  1  3  3  4  3  5  2  2  3  5  --- Script interrumpido ---
<mark class="error">&lt;&lt;&lt;ScriptException>>> en la sentencia '[#3: imprimir randint(1,6),]': 
&lt;&lt;&lt;FuncionException>>> en funcion "randint": Tiempo expirado --> randint(Vector:[1,6])</mark></p>
</div>

<br/><br/>
<h3 class="subSection" id="abstractctx2d">Implementación de soporte gráfico</h3>
<section class="content">
<br/>
<p>Para implementar lienzos 2D y E/S mediante un interfaz gráfico, es necesario implementar el interfaz <code>jme.script.ctx2d.AbstractPrimitivas2D</code>,
y asignar la clase implementante al script, antes de ejecutarlo, mediante <code>Script#getListaPrimitivas#add</code> o 
<code>Script#setListaPrimitivas</code> para asignar una lista de contextos gráficos. Puede utilizarse la clase adaptadora <code>me.script.ctx2d.Primitivas2DAdapter</code>.
</p>
<p><b>Interfaz <code>jme.script.ctx2d.AbstractPrimitivas2D</code>:</b></p>
<pre><code class="java">package jme.script.ctx2d;

import java.io.File;
import java.io.Serializable;
import java.util.List;
import java.util.Map;

import jme.Expresion;
import jme.abstractas.Numero;
import jme.abstractas.Terminal;
import jme.script.Script;
import jme.terminales.RealDoble;
import jme.terminales.Texto;
import jme.terminales.VectorEvaluado;

/**
 * Primitivas gráficas a implementar en cada sistema gráfico
 * @author Miguel Alejandro Moreno Barrientos, (C)2020-2021
 * @since 0.6.2.0, JMEScript 0.2.0
 * @version 0.6.2.1, JMEScript 0.2.0
 */
public interface AbstractPrimitivas2D 
{	
	//////////////////////////////////////////////////////
	// ENUMERACIONES VÁLIDAS PARA PARÁMETROS ENUMERADOS
	//////////////////////////////////////////////////////
	
	/** Estilo de texto */
	static enum ESTILO { /** Texto plano */
						 PLANO,
						 /** Texto en negrita */
						 NEGRITA,
						 /** Texto en cursiva */
						 CURSIVA,
						 /** Texto en negrita y cursiva */
						 NEG_CUR, 
						 OTRO1, OTRO2, OTRO3 };
	/** Estilo de resaltado 3D */
	static enum RECT3D { RESALTADO, GRABADO, NINGUNO, OTRO1, OTRO2, OTRO3 };
	/** Estilo de redondeo de línea */
	static enum CAP { REDONDO, CUADRADO, TOPE, OTRO1, OTRO2, OTRO3 };
	/** Estilo de unión de líneas */
	static enum JOIN { REDONDO, BISEL, INGLETE, OTRO1, OTRO2, OTRO3 };
	/** Estilo de gradiente */
	static enum CICLO { CICLO, REFLEJO, NO_CICLO }
	/** Tipos de puntos */
	static enum PUNTO { /** Punto simple o círculo dependiendo del grosor */
						PIXEL,
						/** Punto con forma de rombo */
						ROMBO,
						/** Punto con forma de cruz */
						CRUZ,
						/** Punto con forma de mira */
						MIRA, 
						OTRO1, OTRO2, OTRO3 };
	/** Tipos de cierre de arco */
	static enum CIERRE { /** Deja el arco abierto */ 
						 ABIERTO,
						 /** Cierra el arco con un segmento */
						 CUERDA,
						 /** Cierra el arco uniendo con el centro */
						 TARTA };
	/** Tipos de segmentos en una ruta */
	static enum RUTA { /** Desplazar a posición */
					   MOVER_A,
					   /** Segmento desde la última posición */
					   LINEA_A,
					   /** Segmento de curva mediante tres nuevos puntos */
					   CURVA_A,
					   /** Segmento de curva mediante dos nuevos puntos */
					   CUAD_A,
					   /** Cerrar ruta */					   
					   CERRAR,
					   /** Aplica regla No Cero */
					   NO_CERO,
					   /** Aplica regla Par-Impar */
					   PAR_IMPAR, 
					   OTRO1, OTRO2, OTRO3 };
	/** Tipos de mensajes */
	static enum MSJ { /** Mensaje de información */
					  INFO,
					  /** Mensaje de advertencia */
					  WARNING,
					  /** Mensaje de error */
					  ERROR,
					  /** Mensaje de consulta al usuario */
					  QUESTION,
					  /** Mensaje plano */
					  PLAIN,
					  /** Mensaje de depuración */
					  DEBUG,
					  /** Mensaje de confirmación */ 
					  CONFIRM,
					  /** Mensaje de éxito */
					  OK, 
					  OTRO1, OTRO2,  OTRO3 }
	/** tipos de entrada de datos por parte del usuario */
	static enum ENTRADA { /** Introducir booleano o valor binario */
						  BOOLEANO,
						  /** Introducir texto directamente sin delimitador 
						   * {@link Texto#DELIMITADOR} */
						  TEXTO,
						  /** Introducir expresión JME */
						  EXPRESION,
						  /** Introducir valor desde conjunto de opciones */
						  OPCIONES, 
						  OTRO1, OTRO2, OTRO3 }

	
	////////////////////////////////////////////////
	// INFORMACIÓN DEL SISTEMA GRÁFICO Y LIBRERÍA
	////////////////////////////////////////////////

	/**
	 * Nombre de entorno gráfico en el que ejecutará JMEScript (ej: Swing, AWT, JavaFx, Android,...)
	 * @return nombre del UI
	 * @since 0.6.2.0, JMEScript 0.2.0
	 */
	String getUIName();
	
	/**
	 * Nombre de versión del entorno gráfico (si existe)
	 * @return nombre de la versión del UI
	 * @since 0.6.2.0, JMEScript 0.2.0
	 */
	String getUIVersionName();
	
	/**
	 * Versión del entorno gráfico (ej: 0.2.0, v3.7)
	 * @return versión numérica del UI
	 * @since 0.6.2.0, JMEScript 0.2.0
	 */
	String getUIVersion();
	
	/**
	 * Nombre de esta implementación 
	 * @return nombre
	 */
	String getPrim2DName();
	
	/**
	 * Nombre de versión de esta implementación
	 * @return nombre de versión
	 */
	String getPrim2DVersionName();
	
	/**
	 * Versión de esta implementación
	 * @return versión numérica de la versión
	 */
	String getPrim2DVersion();

	
	////////////////////////////////////
	// PRIMITIVAS DE CONTEXTO GRÁFICO
	////////////////////////////////////	
	
	/**
	 * Obtiene el componente padre del lienzo
	 * @return componente padre o <i>null</i>
	 */
	Object getPadre();
	
	/**
	 * Inicia un lienzo (canvas) para dibujar y le asigna un índice único
	 * @param indice índice del contexto {@code idx>0}
	 * @param ancho ancho del lienzo
	 * @param alto alto del lienzo
	 * @param posX posición inicial x
	 * @param posY posición inicial y
	 * @param titulo título del lienzo (o null)
	 */
	void iniciarContexto( int indice, int ancho, int alto, int posX, int posY, String titulo );
	
	/**
	 * Cerrar lienzo
	 */
	void finalizarContexto();
	
	/**
	 * Comprobar si se ha iniciado el lienzo
	 * @return {@code true} si está iniciado
	 */
	boolean esContextoIniciado();
	
	/**
	 * Repintar el lienzo especificado (generalmente éste)
	 * @param indice índice del lienzo
	 */
	void repintar( int indice );
	
	/**
	 * Ancho del lienzo 
	 * @return ancho en pixels del lienzo
	 */
	int getAncho();
	
	/**
	 * Alto del lienzo 
	 * @return alto en pixels del lienzo
	 */
	int getAlto();	
	
	/**
	 * Ancho del dispositivo 
	 * @return ancho del dispositivo en pixels
	 */
	int getAnchoPantalla();
	
	/**
	 * Alto del dispositivo  
	 * @return alto del dispositivo en pixels
	 */
	int getAltoPantalla();	

	/**
	 * Obtiene un mapa de propiedades del sistema definidas por el desarrollador 
	 * @return mapa de propiedades del sistema 
	 */
	Map<Object,Object> getPropiedadesEntorno();
	
	
	//////////////////////////////
	// PRIMITIVAS DE E/S  (I/O)
	//////////////////////////////
	
	/**
	 * Muestra un mensaje al usuario mediante diálogo o tostada
	 * @param msj mensaje
	 * @param tipo {@link MSJ}
	 * @param posX coordenada X del mensaje. Puede ser <i>null</i>
	 * @param posY coordenada Y del mensaje. Puede ser <i>null</i>
	 * @param tiempo tiempo a mostrar el mensaje. Puede ser <i>null</i>
	 */
	void mostrarMensaje( String msj, MSJ tipo, Integer posX, Integer posY, Integer tiempo );
	
	/**
	 * Lectura de entradas de usuario.<br>
	 * El valor almacenado deberá ser
	 * <b>{@link Expresion.ERROR#__error1__}</b>
	 * si se cancela la entrada.<br>
	 * Si se evalúa un expresión y se obtiene un error, el valor almacenado deberá ser
	 * <b>{@link Expresion.ERROR#__error2__}</b>
	 * @param script script actual
	 * @param entrada tipo de entrada de usuario; {@link ENTRADA}
	 * @param varname variable para almacenar el valor
	 * @param msj mensaje de petición de datos al usuario
	 * @param opciones opciones para el tipo {@link ENTRADA#OPCIONES}. Puede ser <i>null</i>
	 */
	void entradaUsuario( Script script, ENTRADA entrada, String varname, String msj, 
						 String[] opciones );
	
	/**
	 * Lista de pulsaciones de teclas a consumir 
	 * @return lista de pulsaciones
	 */
	List<AbstractKeyStroke> getStrokeList();
	
	/**
	 * Lista de toques en pantalla o clicks de ratón a consumir 
	 * @return lista de eventos de ratón/toque
	 */
	List<AbstractRatonEvent> getRatonEventList();
	
	/**
	 * Permite seleccionar uno o varios archivos del sistema 
	 * @param path ruta actual <i>(<b>ruta vacía</b> mantiene el directorio actual, 
	 *             <b>ruta errónea</b> establece la ruta por defecto)</i>
	 * @param titulo título de un posible diálogo de selección o <i>null</i> para valor por defecto
	 * @return array de archivos seleccionados con la ruta completa.
	 *         Si no se selecciona ninguno devuelve <i>array vacío</i> y <i>null</i> si hay un error 
	 */
	File[] seleccionarArchivos( String path, String titulo );
		
	
	///////////////////////////////////
	// PRIMITIVAS GRÁFICAS
	///////////////////////////////////	
	
	// COLOR	
	/**
	 * Obtiene una factoría (definida a partir de un AbstractColor) para obtener nuevos colores
	 * @return factoría de color
	 */
	AbstractColor getColorFactory();
	
	/**
	 * Establecer color de línea del lienzo
	 * @param color color de línea
	 */
	void setColor( AbstractColor color );
	/**
	 * Establecer color de relleno del lienzo
	 * @param color color de relleno
	 */
	void setRelleno( AbstractColor color );
	/**
	 * Establecer color de fondo del lienzo
	 * @param color color de fondo
	 */
	void setFondo( AbstractColor color );
	
	/**
	 * Color de línea del lienzo
	 * @return color de línea
	 */
	AbstractColor getColor();
	/**
	 * Color de relleno del lienzo
	 * @return color de relleno
	 */
	AbstractColor getRelleno();
	/**
	 * Color de fondo del lienzo
	 * @return color de fondo
	 */
	AbstractColor getFondo();
	
	// TRAZO
	void setTrazo( float grosor );
	void setTrazo( float grosor, CAP extremo, JOIN union, Float inglete, float[] raya, 
				   Float faseRaya );
	
	// GRADIENTE	
	/**
	 * Gradiente aplicado a relleno y línea
	 * @param x1 inicio x del primer color o centro x
	 * @param y1 inicio y del primer color o centro y
	 * @param x2 final x del último color o foco X
	 * @param y2 final y del último color o foco y
	 * @param radio radio del gradiente radial
	 * @param fracciones división ponderada del patrón de color
	 * @param colores color asociado a cada fracción
	 * @param ciclo {@link CICLO#CICLO}, {@link CICLO#REFLEJO}, {@link CICLO#NO_CICLO} 
	 * @param transform matriz de transformación (puede ser AffineTransform en escritorio o Matrix
	 *                  en Android)
	 */
	void setGradiente( double x1, double y1, double x2, double y2, Double radio, float[] fracciones,
					   AbstractColor[] colores, CICLO ciclo, Object transform );
	
	// TRANSFORMACIONES
	
	/**
	 * Matriz de transformación del lienzo {@code [[sx,shx,tx],[shy,sy,ty],[0,0,1]]}
	 * @param storeMatrizTransformacion matriz 3x3 inicializada donde se almacenará la matriz
	 * @return la propia matriz {@code storeMatrizTransformacion} actualizada
	 */
	double[] getMatriz( double[] storeMatrizTransformacion );
	/**
	 * Establece la matriz del lienzo {@code [[sx,shx,tx],[shy,sy,ty],[0,0,1]]}
	 * @param matrizTransformacion matriz 3x3
	 */
	void setMatriz( double[] matrizTransformacion );
	
	// LIMPIAR ZONA
	/**
	 * Borra una parte del lienzo, con el color de fondo especificado
	 * @param x extremo superior izquierda x
	 * @param y extremo superior izquierda y
	 * @param ancho ancho del rectángulo de borrado
	 * @param alto alto del rectángulo de borrado
	 * @param cfondo color de fondo
	 */
	void limpiar( int x, int y, int ancho, int alto, AbstractColor cfondo );	
	
	// FIGURAS Y TEXTO
	
	/**
	 * Dibuja un punto del tipo especificado, con el grosor establecido con 'trazo' y color 
	 * de línea establecido
	 * @param x coordenada X del punto
	 * @param y coordenada Y del punto
	 * @param tipo {@link PUNTO}
	 */
	void punto( double x, double y, PUNTO tipo );
	
	/**
	 * Traza segmento entre dos puntos con el color de línea establecido
	 * @param x1 coordenada X del extremo inicial
	 * @param y1 coordenada Y del extremo inicial
	 * @param x2 coordenada X del extremo final
	 * @param y2 coordenada Y del extremo final
	 */
	void segmento( double x1, double y1, double x2, double y2 );
	
	/**
	 * Dibuja circunferencias, círculos y arcos
	 * @param cx coordenada X del centro
	 * @param cy coordenada Y del centro
	 * @param radio radio
	 * @param ang ángulo inicial (grados)
	 * @param arco longitud del arco (grados)
	 * @param tipo {@link CIERRE#ABIERTO}, {@link CIERRE#CUERDA}, {@link CIERRE#TARTA}
	 * @param relleno {@code verdadero} para dibujar el interior (círculo) con color de relleno
	 * @param borde {@code verdadero} para dibujar la circunferencia o arco. <u>Si {@code relleno}
	 * 				es {@code falso}, debe dibujarse aunque {@code borde} sea falso</u>
	 */
	void circunferencia( double cx, double cy, double radio, double ang, double arco, CIERRE tipo, 
						 boolean relleno, boolean borde );
	
	/**
	 * Dibuja elipses
	 * @param x1 extremo superior izquierda x
	 * @param y1 extremo superior izquierda y
	 * @param x2 extremo inferior derecha x
	 * @param y2 extremo inferior derecha y
	 * @param relleno <i>true</i> para dibujar el interior con color de relleno
	 * @param borde {@code verdadero} para dibujar el borde. <u>Si {@code relleno}
	 * 				es {@code falso}, debe dibujarse aunque {@code borde} sea falso</u>
	 */
	void elipse( double x1, double y1, double x2, double y2, boolean relleno, boolean borde );
	
	/**
	 * Dibuja un rectángulo recto, redondeado o 3D. Con relleno y/o borde.
	 * @param x1 x extremo superior izquierda
	 * @param y1 y extremo superior izquierda
	 * @param x2 x extremo inferior derecha
	 * @param y2 y extremo inferior derecha
	 * @param anchoArco ancho esquinas redondeadas
	 * @param altoArco alto esquinas redondeadas
	 * @param relleno <i>true</i> para dibujar el interior con color de relleno
	 * @param borde {@code verdadero} para dibujar el borde. <u>Si {@code relleno}
	 * 				es {@code falso}, debe dibujarse aunque {@code borde} sea falso</u>
	 * @param rect3d {@link RECT3D#GRABADO}, {@link RECT3D#RESALTADO}, {@link RECT3D#NINGUNO}
	 */
	void rectangulo( double x1, double y1, double x2, double y2, double anchoArco, double altoArco, 
					 boolean relleno, boolean borde, RECT3D rect3d );
	
	/**
	 * Dibuja un polígono o polilínea
	 * @param x array de coordenadas x
	 * @param y array de coordenadas y (mismo tamaño y punto correspondiente)
	 * @param cerrar {@code verdadero} para cerrar primer y último punto
	 * @param relleno <i>true</i> para dibujar el interior con color de relleno
	 * @param borde {@code verdadero} para dibujar el borde. <u>Si {@code relleno}
	 * 				es {@code falso}, debe dibujarse aunque {@code borde} sea falso</u>
	 */
	void poligono( double[] x, double[] y, boolean cerrar, boolean relleno, boolean borde );
	
	/**
	 * Dibuja un texto.
	 * <br>Puede incluir sombreado si <i>{@code sombraX}</i> o <i>{@code sombraY}</i> no son 
	 * iguales a 0. El color del sombreado será el <i><b>color de relleno</b></i>
	 * @param texto texto a graficar
	 * @param posX coordenada X del texto
	 * @param posY coordenada Y del texto
	 * @param tama tamaño del texto
	 * @param sombraX desplazamiento de la sombra en X
	 * @param sombraY desplazamiento de la sombra en Y
	 * @param familia familia del texto
	 * @param estilo estilo del texto; {@link ESTILO}
	 */
	void texto( String texto, int posX, int posY, int tama, int sombraX, int sombraY, 
				String familia, ESTILO estilo );

	/**
	 * Devuelve la dimensión del texto a graficar
	 * @param texto texto a graficar
	 * @param tama tamaño del texto
	 * @param sombraX desplazamiento de la sombra en X
	 * @param sombraY desplazamiento de la sombra en Y
	 * @param familia familia del texto
	 * @param estilo estilo del texto; {@link ESTILO}
	 * @return array <b>{@code [ancho,alto]}</b>
	 */
	int[] medirTexto( String texto, int tama, int sombraX, int sombraY, String familia, 
					  ESTILO estilo );
	
	/**
	 * Dibuja una figura en base a una ruta especificada por diferentes acciones
	 * @param accionPuntos
	 * @param regla regla de relleno del interior: {@link RUTA#PAR_IMPAR}, {@link RUTA#NO_CERO}
	 * @param relleno <i>true</i> para dibujar el interior con color de relleno
	 * @param borde {@code verdadero} para dibujar el borde. <u>Si {@code relleno}
	 * 				es {@code falso}, debe dibujarse aunque {@code borde} sea falso</u>
	 */
	void ruta( AccionPuntos[] accionPuntos, RUTA regla, boolean relleno, boolean borde );
	
	
	////////////////////////////////////
	// INTERFACES Y CLASES ABSTRACTAS
	////////////////////////////////////

	/**
	 * Holder para la primitiva 
	 * {@link AbstractPrimitivas2D#ruta(AccionPuntos[], RUTA, boolean, boolean)}
	 */
	static class AccionPuntos
	{
		public RUTA accion;
		public double[][] puntos;
	}

	/**
	 * Implementa de forma abstracta un color ARGB, dado por sus canales
	 */
	static abstract class AbstractColor implements Serializable
	{
		private static final long serialVersionUID = 1L;

		// MÉTODOS FACTORÍA
		/**
		 * Obtiene un color a partir de los canales RGB
		 * @param r red
		 * @param g green
		 * @param b blue
		 * @return nuevo color
		 */
		public abstract AbstractColor nuevaInstancia( int r, int g, int b );
		/**
		 * Obtiene un color a partir de los canales ARGB
		 * @param r reg
		 * @param g green
		 * @param b blue
		 * @param a alpha
		 * @return nuevo color
		 */
		public abstract AbstractColor nuevaInstancia( int r, int g, int b, int a );
		/**
		 * Obtiene un color a partir de una cadena hexadecimal (ej.: #AABBCC)
		 * @param stringcolor cadena hexadecimal
		 * @return nuevo color
		 */
		public AbstractColor nuevaInstancia( String stringcolor )
		{
			throw new UnsupportedOperationException();
		}
		/**
		 * Obtiene un color a partir de un entero AARRGGBB desde el bit 0 a 31
		 * @param intcolor entero de 32 bits
		 * @return nuevo color
		 */
		public AbstractColor nuevaInstancia( int intcolor )		
		{
			throw new UnsupportedOperationException();
		}
		
		/**
		 * Convierte un terminal a un formato de color aceptado
		 * @param color color como terminal compatible
		 * @param factory factoría de color
		 * @return nuevo color
		 */
		public static AbstractColor colorDesdeTerminal( Terminal color, AbstractColor factory )
		{
			// RGB & RGBA
			if ( color.esVector() )
			{
				final VectorEvaluado vcolor = (VectorEvaluado) color;
				try
				{
					int r = ((Numero) vcolor.getComponente(0)).ent(),
						g = ((Numero) vcolor.getComponente(1)).ent(),
						b = ((Numero) vcolor.getComponente(2)).ent();
				
					if ( vcolor.dimension() == 4 )  // RGBA
						return factory.nuevaInstancia( r, g, b, 
													   ((Numero) vcolor.getComponente(3)).ent() );
					else  // RGB
						return factory.nuevaInstancia( r, g, b );
				}
				catch ( Exception e )
				{
					throw new IllegalArgumentException( 
												color + " no es un formato de color aceptado", e );
				}
			}
			// color mediante entero
			else if ( color.esEntero() )
				return factory.nuevaInstancia( ((Numero) (color)).ent() );
			// color por formato de texto
			else if ( color.esTexto() )
				return factory.nuevaInstancia( ((Texto) color).textoPlano() );
			else
				throw new IllegalArgumentException( color + " no es un formato de color aceptado" );
		}
		
		/**
		 * Devuelve el canal rojo del color
		 * @return red
		 */
		public abstract int red();
		/**
		 * Devuelve el canal green del color
		 * @return green
		 */
		public abstract int green();
		/**
		 * Devuelve el canal azul del color
		 * @return blue
		 */
		public abstract int blue();
		/**
		 * Devuelve el canal alpha del color
		 * @return alpha
		 */
		public abstract int alpha();
		/**
		 * Devuelve el color como entero
		 * @return AARRGGBB (0-31 bits)
		 */
		public int intcolor() { throw new UnsupportedOperationException(); }
		/**
		 * Devuelve el color como cadena
		 * @return cadena hexadecimal
		 */
		public int stringcolor() { throw new UnsupportedOperationException(); }
		/**
		 * Devuelve el color como vector JME
		 * @return vector [R,G,B,A]
		 */
		public VectorEvaluado vectorColor() 
		{
			return new VectorEvaluado( new RealDoble( red() ),
									   new RealDoble( green() ),
									   new RealDoble( blue() ),
									   new RealDoble( alpha() ) );
		}
		
	}  // class AbstractColor
	
	/**
	 * Intefaz para la representación de pulsaciones de teclas 
	 */
	static interface AbstractKeyStroke extends Serializable 
	{
		/** Zona del teclado */
		static enum LOCALIZACION { ESTANDAR, IZQUIERDA, DERECHA, NUMPAD, DESCONOCIDA }
		/** Valores para los modificadores (máscaras) del evento, idénticos a los especificados para 
		 * {@link java.awt.event.InputEvent}*/
		static int SHIFT = 64,
				   CONTROL = 128,
				   META = 256,
				   ALT = 512,
				   BUTTON1 = 1024,
				   BUTTON2 = 2048,
				   BUTTON3 = 4096,
				   ALT_GRAPH = 8192;				   
		
		/** key code de la pulsación */
		int getKeycode();
		/** marca de tiempo del evento (ms) */
		long getTimeStamp();
		/** modificadores de la pulsación 
		 * @return {@link #SHIFT}, {@link #CONTROL}, {@link #META}, {@link #ALT}, {@link #BUTTON1}, 
		 *         {@link #BUTTON2}, {@link #BUTTON3}, {@link #ALT_GRAPH}
		 * */
		int getModifiers();
		/** modificadores como texto (dependiente de la plataforma) */
		String getModifiersText();
		/** carácter pulsado si corresponde a un simbolo no de control */ 
		char getKeychar();
		/** <i>verdadero</i> si la tecla es soltada, <i>falso</i> para presionada */
		boolean isKeyReleased();
		/** Localización en que ocurre el evento (dos SHIFTS, dos CONTROL, teclado numérico,...)*/
		LOCALIZACION getLocalizacion();
		/** <i>verdadero</i> si es una tecla de acción (teclas de dirección, CAPS, PAGE DOWN,...)*/
		boolean isAccion();
		
	}  // interface AbstractKeyStroke
	
	/**
	 * Interfaz para la representación de eventos de ratón o toques táctiles
	 */
	static interface AbstractRatonEvent extends Serializable 
	{
		/** botón pulsado (B2 central) */
		static enum BOTON { BOTON1, BOTON2, BOTON3, NO_BOTON, OTRO1, OTRO2, OTRO3 };
		/** tipo de evento de ratón o toque */
		static enum RATON_ID { PRESSED, RELEASED, CLICKED, MOVED, DRAGGED, ENTERED, EXITED, WHEEL, 
							   OTRO1, OTRO2, OTRO3 }
		
		/** id de evento */
		RATON_ID getId();
		/** marca de tiempo del evento (ms) */
		long getTimeStamp();
		/** array [x,y] respecto a componente padre */
		int[] getPosicion();
		/** array [x,y] respecto a pantalla */
		int[] getPosicionEnPantalla();
		/** id de botón */
		BOTON getButton();
		/** nº de clicks */
		int getClicks();
		/** rotación de rueda */
		double getRotacion();
		
	}  // interface AbstractRatonEvent
	
}  // interface AbstractPrimitivas2D
</code></pre>
<hr/>
<p>El siguiente es un ejemplo de implementación incompleta del adaptador para <b>Swing</b>. JMEscriptGUI completa esta implementación.</p>
<pre><code class="java">package swing_primitivas;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.LinearGradientPaint;
import java.awt.MultipleGradientPaint.ColorSpaceType;
import java.awt.MultipleGradientPaint.CycleMethod;
import java.awt.RadialGradientPaint;
import java.awt.Shape;
import java.awt.Toolkit;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.awt.geom.AffineTransform;
import java.awt.geom.Arc2D;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Line2D;
import java.awt.geom.Path2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.RoundRectangle2D;
import java.io.File;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import javax.swing.JFileChooser;
import javax.swing.JOptionPane;

import jme.Expresion;
import jme.ExpresionThread;
import jme.abstractas.Token;
import jme.script.Script;
import jme.script.ScriptException;
import jme.script.ctx2d.AbstractPrimitivas2D;
import jme.script.ctx2d.Primitivas2DAdapter;
import jme.terminales.Booleano;
import jme.terminales.Texto;

/**
 * Implementación básica de {@link AbstractPrimitivas2D} para Swing. 
 * @author Miguel Alejandro Moreno Barrientos, (C)2021
 * @since 0.1.0, JME v0.6.2.0, JMEScript 0.1.3.0
 */
public class JMEPrimitivas2DParaSwing extends Primitivas2DAdapter 
{
	private Graphics2D g2;
	
	/** máximo tiempo de ejecución de las expresiones en la entrada (ms) */
	public long maxTiempoDeEvaluacion = 4000L;
	
	public static JFileChooser fileChooser;
	
	private List<AbstractKeyStroke> strokeList = 
							Collections.synchronizedList( new LinkedList<AbstractKeyStroke>() );
	private List<AbstractRatonEvent> ratonEventList = 
							Collections.synchronizedList( new LinkedList<AbstractRatonEvent>() );
	
	protected Color colorRelleno = Color.BLACK;  // color de relleno en figuras
	
	public JMEPrimitivas2DParaSwing() {}
	
	public JMEPrimitivas2DParaSwing( Graphics2D g2 ) 
	{
		this();
		this.g2 = g2;
	}
	
	public Graphics2D getGraphics() { return g2; }	
	public void setGraphics( Graphics2D g2 ) { this.g2 = g2; }
	
	@Override
	public String getUIName() { return "Swing"; }
	
	@Override
	public String getUIVersion() 
	{ 
		try
		{
			return System.getProperty("java.version");
		}
		catch ( SecurityException e )
		{
			return "?";
		}
	}
	
	@Override
	public String getPrim2DName() { return "Implementacion Basica de Primitivas2D para SWING"; }
	
	@Override
	public String getPrim2DVersionName() { return "Cuarentena"; }
	
	@Override
	public String getPrim2DVersion() { return "0.1.0"; }
	
	@Override
	public int getAnchoPantalla() { return Toolkit.getDefaultToolkit().getScreenSize().width; }
	
	@Override
	public int getAltoPantalla() { return Toolkit.getDefaultToolkit().getScreenSize().height; }

	@Override
	public void mostrarMensaje( String msj, MSJ tipo, Integer posX, Integer posY, Integer tiempo ) 
	{
		int msjTipo;
		switch( tipo )
		{
			case WARNING: msjTipo = JOptionPane.WARNING_MESSAGE; break;
			case ERROR: msjTipo = JOptionPane.ERROR_MESSAGE; break;
			case QUESTION: msjTipo = JOptionPane.QUESTION_MESSAGE; break;
			case PLAIN: msjTipo = JOptionPane.PLAIN_MESSAGE; break;
			default: msjTipo = JOptionPane.INFORMATION_MESSAGE;
		}
		JOptionPane.showConfirmDialog( getPadre() instanceof Component 
									   ? (Component) getPadre() 
									   : null, 
									   msj, 
									   "Script mensaje:", 
									   JOptionPane.OK_CANCEL_OPTION, 
									   msjTipo ); 
	}
	
	@Override
	public void entradaUsuario( Script script, ENTRADA entrada, String varname, String msj, 
								String[] opciones ) 
	{
		final Map<String,Token> scriptVars = script.getVarMap();
		final Component padre = getPadre() instanceof Component ? (Component) getPadre() : null;
		
		switch ( entrada )
		{
			default:
			// solicitud de texto
			case TEXTO:
			{
				String txt = JOptionPane.showInputDialog( padre, msj, 
												String.format( "Solicitud de <%s> JME para '%s'", 
														Texto.class.getSimpleName(), varname ),
												JOptionPane.QUESTION_MESSAGE );
				if ( txt == null )  // entrada cancelada
					txt = Expresion.ERROR.__error1__.name();
				// establecer variable en script
				scriptVars.put( varname, new Texto( txt ) ); 
				break;
			}
			// solicitud de expresión
			case EXPRESION:    
			{
				final String exptxt = JOptionPane.showInputDialog( padre, msj, 
												String.format( "Solicitud de <%s> JME para '%s'", 
														Expresion.class.getSimpleName(), varname ),
												JOptionPane.QUESTION_MESSAGE ); 
				if ( exptxt == null )  // entrada cancelada
				{
					scriptVars.put( varname, new Texto( Expresion.ERROR.__error1__.name() ) );
					break;
				}

				final ExpresionThread expThread;
				try
				{
					// crear expresión
					final Expresion exp = new Expresion( exptxt )
									.setVariables( new HashMap<String,Token>( script.getVarMap() ) );
					// crear hilo y ejecutar
					expThread = new ExpresionThread( exp, maxTiempoDeEvaluacion );
					expThread.startAndJoin();
				}
				catch ( Throwable e )
				{
					scriptVars.put( varname, new Texto( Expresion.ERROR.__error2__.name() ) );
					break;
				}
				// establecer variable en script
				scriptVars.put( varname, expThread.getResultado() ); 
				break;
			}
			// solicitud de confirmación (booleano)
			case BOOLEANO:
			{
				// seleccionar SI/NO
				final int opcion = JOptionPane.showConfirmDialog( padre, msj, 
										String.format( "Solicitud de <%s> para '%s'", 
													   Booleano.class.getSimpleName(), varname ),
										JOptionPane.YES_NO_OPTION ); 
				if ( opcion == JOptionPane.CLOSED_OPTION )  // entrada cancelada
					scriptVars.put( varname, new Texto( Expresion.ERROR.__error1__.name() ) );
				else  // establecer variable en script
					scriptVars.put( varname, Booleano.booleano( opcion == JOptionPane.YES_OPTION ) ); 
				break;
			}
			// selección de opciones
			case OPCIONES:
			{
				// obtener índice de la opción
				final int opcion = JOptionPane.showOptionDialog( padre, msj, 
						"Opciones para '" + varname + "'", 
						JOptionPane.NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, opciones, null );
				if ( opcion == JOptionPane.CLOSED_OPTION )  // entrada cancelada
					scriptVars.put( varname, new Texto( Expresion.ERROR.__error1__.name() ) );
				else  // establecer variable en script
					scriptVars.put( varname, new Texto( opciones[opcion] ) ); 
				break;
			}
		}		
	}
	
	/**
	 * {@inheritDoc}
	 * <br><br>
	 * <i>Nota: <b>aunque sea sincronizada, es necesario acceder en bloque, o se obtendrá en 
	 * ocasiones un error de concurrencia<b></i> 
	 */
	@Override	
	public List<AbstractKeyStroke> getStrokeList() { return strokeList; }
	
	/**
	 * {@inheritDoc}
	 * <br><br>
	 * <i>Nota: <b>aunque sea sincronizada, es necesario acceder en bloque, o se obtendrá en 
	 * ocasiones un error de concurrencia<b></i> 
	 */
	@Override
	public List<AbstractRatonEvent> getRatonEventList() { return ratonEventList; }

	@Override
	public File[] seleccionarArchivos( String path, String titulo ) 
	{
		fileChooser = fileChooser != null ? fileChooser : new JFileChooser();
		fileChooser.setMultiSelectionEnabled(true);
		fileChooser.setFileSelectionMode( JFileChooser.FILES_AND_DIRECTORIES );
		fileChooser.setCurrentDirectory( path != null ? new File(path) : null );
		fileChooser.setDialogTitle( titulo );
		fileChooser.updateUI();
		switch( fileChooser.showOpenDialog( getPadre() instanceof Component 
											? (Component) getPadre() 
											: null ) )
		{
			case JFileChooser.APPROVE_OPTION: return fileChooser.getSelectedFiles();
			case JFileChooser.CANCEL_OPTION: return new File[0];
			case JFileChooser.ERROR_OPTION:
			default: return null;
		}		
	}
	
	@Override
	public void limpiar( int x, int y, int ancho, int alto, AbstractColor cfondo ) 
	{
		// guardar color y matriz originales
		final AffineTransform oriMatriz = g2.getTransform();
		final Color oriColor = g2.getColor();
		// establecer matriz identidad
		g2.setTransform( new AffineTransform() );
		// establecer color de fondo
		if ( cfondo != null )
			g2.setColor( new Color( cfondo.red(), cfondo.green(), cfondo.blue(), cfondo.alpha() ) );
		else  if ( g2.getPaint() instanceof Color )
			g2.setColor( g2.getBackground() );
		// dibujar rectángulo de fondo
		g2.fill( new Rectangle2D.Double( x, y, ancho, alto ) );
		// recuperar color y matriz originales
		g2.setColor( oriColor );			
		g2.setTransform( oriMatriz );
	}
	
	@Override
	public AbstractColor getColorFactory() { return new JSColor(); }
	
	public static class JSColor extends AbstractColor
	{
		private static final long serialVersionUID = 1L;
		
		protected Color color = Color.BLACK;
		
		public JSColor() {}
		public JSColor( Color color ) { this.color = color; }
		public JSColor( int r, int g, int b, int a ) { color = new Color( r, g, b, a ); }
		public JSColor( int r, int g, int b ) { this( r, g, b, 255 ); }
		public JSColor( int intcolor ) { color = new Color( intcolor, true ); }
		public JSColor( String stringcolor ) { color = Color.decode( stringcolor ); }

		@Override
		public JSColor nuevaInstancia( int r, int g, int b, int a ) 
		{
			return new JSColor( r, g, b, a );
		}
		
		@Override
		public JSColor nuevaInstancia( int r, int g, int b ) 
		{
			return new JSColor( r, g, b );
		}
		
		@Override
		public JSColor nuevaInstancia( String stringcolor ) 
		{
			return new JSColor( stringcolor );
		}
		
		@Override
		public JSColor nuevaInstancia( int intcolor ) 
		{
			return new JSColor( intcolor );
		}
		
		@Override
		public int red() { return color.getRed(); }
		
		@Override
		public int green() { return color.getGreen(); }
		
		@Override
		public int blue() { return color.getBlue(); }

		@Override
		public int alpha() { return color.getAlpha(); }

	}  // class JSColor
	

	/////////////////////////
	// PRIMITIVAS GRÁFICAS
	/////////////////////////
	
	@Override
	public void setColor( AbstractColor color ) 
	{
		g2.setColor( new Color( color.red(), color.green(), color.blue(), color.alpha() ) );
	}
	
	@Override
	public AbstractColor getColor() 
	{
		return esContextoIniciado() ? new JSColor( g2.getColor() ) : new JSColor();
	}
	
	@Override
	public void setRelleno( AbstractColor color ) 
	{
		// eliminar gradiente si se modifica el relleno
		if ( !(g2.getPaint() instanceof Color) )
			g2.setPaint( colorRelleno );
		
		colorRelleno = new Color( color.red(), color.green(), color.blue(), color.alpha() );
	}
	
	@Override
	public AbstractColor getRelleno() 
	{
		return esContextoIniciado() ? new JSColor( colorRelleno ) : new JSColor();
	}
	
	@Override
	public void setFondo( AbstractColor color ) 
	{
		final Color c = new Color( color.red(), color.green(), color.blue(), color.alpha() );

		// eliminar gradiente si se modifica el fondo
		if ( !(g2.getPaint() instanceof Color) )
			g2.setPaint( c );
		
		g2.setBackground( c );
	}
	
	@Override
	public AbstractColor getFondo() 
	{
		return esContextoIniciado() ? new JSColor( g2.getBackground() ) : new JSColor();
	}
	
	@Override
	public double[] getMatriz( double[] storeMatrizTransformacion ) 
	{
		if ( !esContextoIniciado() )
			return null;
		
		getGraphics().getTransform().getMatrix(storeMatrizTransformacion);
		
		return storeMatrizTransformacion;
	}
	
	@Override
	public void setMatriz( double[] matrizTransformacion ) 
	{
		getGraphics().setTransform( new AffineTransform( matrizTransformacion ) );
	}

	@Override
	public void setTrazo( float grosor )
	{
		getGraphics().setStroke( 
						 new BasicStroke( grosor, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND ) );
	}
	
	@Override
	public void setTrazo( float grosor, CAP extremo, JOIN union, Float inglete, float[] raya, 
						  Float faseRaya )
	{
		final BasicStroke oldStroke = g2.getStroke() instanceof BasicStroke 
									  ? (BasicStroke) g2.getStroke() 
									  : new BasicStroke();
									
	    int awtExtremo = ((BasicStroke) g2.getStroke()).getEndCap();
		if ( extremo != null )
		{
			switch ( extremo )
			{
				case REDONDO: awtExtremo = BasicStroke.CAP_ROUND; break;
				case TOPE: awtExtremo = BasicStroke.CAP_BUTT; break;
				case CUADRADO: awtExtremo = BasicStroke.CAP_SQUARE; break;
				default:
			}
		}
		
	    int awtUnion = ((BasicStroke) g2.getStroke()).getLineJoin();
		if ( union != null )
		{
			switch ( union )
			{
				case BISEL: awtUnion = BasicStroke.JOIN_BEVEL; break;
				case INGLETE: awtUnion = BasicStroke.JOIN_MITER; break;
				case REDONDO: awtUnion = BasicStroke.JOIN_ROUND; break;
				default:
			}
		}		
		g2.setStroke( new BasicStroke( grosor, 
									   awtExtremo, 
									   awtUnion, 
									   inglete != null ? inglete : oldStroke.getMiterLimit(), 
									   raya != null 
									   ? (raya.length == 1 && raya[0] == 0f ? null : raya) 
									   : oldStroke.getDashArray(), 
									   faseRaya != null ? faseRaya : oldStroke.getDashPhase() ) );
	}
	
	@Override
	public void setGradiente( double x1, double y1, double x2, double y2, Double radio, 
							  float[] fracciones, AbstractColor[] colores, CICLO ciclo, 
							  Object transform ) 
	{
		// convertir ciclo desde especificación a AWT
		final CycleMethod metCiclo;
		switch ( ciclo )
		{
			default:
			case CICLO: metCiclo = CycleMethod.REPEAT; break;
			case REFLEJO: metCiclo = CycleMethod.REFLECT; break;
			case NO_CICLO: metCiclo = CycleMethod.NO_CYCLE; break;
		}
		// convertir colores
		final Color[] awtColores = new Color[colores.length];
		for ( int i = 0; i < colores.length; i++ )
			awtColores[i] = new Color( colores[i].red(), colores[i].green(), 
									   colores[i].blue(), colores[i].alpha() );
		
		// gradiente lineal
		if ( radio == null )
		{
			final LinearGradientPaint lgrad = new LinearGradientPaint( 
						new Point2D.Double( x1, y1 ), new Point2D.Double( x2, y2 ), 
						fracciones, awtColores, metCiclo, ColorSpaceType.LINEAR_RGB, 
						transform == null ? new AffineTransform() : (AffineTransform) transform );
			g2.setPaint( lgrad );
		}
		// gradiente radial
		else
		{
			final RadialGradientPaint rgrad = new RadialGradientPaint( 
					new Point2D.Double( x1, y1 ), radio.floatValue(), new Point2D.Double( x2, y2 ), 
					fracciones, awtColores, metCiclo, ColorSpaceType.LINEAR_RGB, 
					transform == null ? new AffineTransform() : (AffineTransform) transform );
			g2.setPaint( rgrad );					
		}
	}
	
	@Override
	public void punto( double x, double y, PUNTO tipo ) 
	{
		switch ( tipo )
		{
			default:
			case PIXEL: g2.draw( new Line2D.Double( x, y, x, y ) ); break;
			case ROMBO: 
			{
				final float grosor = ((BasicStroke) g2.getStroke()).getLineWidth();
				final double[] valoresX = { x, x + grosor, x, x - grosor },
							   valoresY = { y + grosor, y, y - grosor, y };				
				final Path2D poly = new Path2D.Double();				

				poly.moveTo( valoresX[0], valoresY[0] );
				for( int i = 1; i < valoresX.length; i++ )
				   poly.lineTo(valoresX[i], valoresY[i]);
				poly.closePath();
				
				g2.fill( poly );
				break;
			}
			case CRUZ: 
			{
				final float grosor = ((BasicStroke) g2.getStroke()).getLineWidth();
				g2.draw( new Line2D.Double( x - grosor, y, x + grosor, y ) );
				g2.draw( new Line2D.Double( x, y - grosor, x, y + grosor ) );
				break;
			}
			case MIRA: 
			{
				final float grosor = ((BasicStroke) g2.getStroke()).getLineWidth(),
							grosor2 = grosor*3/2f;
				g2.draw( new Line2D.Double( x, y + grosor2, x, y + grosor*2 ) );
				g2.draw( new Line2D.Double( x, y - grosor2, x, y - grosor*2 ) );
				g2.draw( new Line2D.Double( x + grosor2, y, x + grosor*2, y ) );
				g2.draw( new Line2D.Double( x - grosor2, y, x - grosor*2, y ) );
				break;
			}
		}
	}
	
	@Override
	public void segmento( double x1, double y1, double x2, double y2 ) 
	{
		g2.draw( new Line2D.Double( x1, y1, x2, y2 ) );
	}

	/**
	 * {@inheritDoc}<br><br>
	 * <b>Nota:</b> <i>los rectángulos 3D no aceptan valores flotantes, por lo que serán redondeados 
	 * a enteros. Las coordenadas normalizadas a rangos pequeños como [0,1] no funcionarán 
	 * correctamente</i>.<br>
	 * <b>Nota2:</b> <i>No dibuja rectángulos redondeados 3D</i>.
	 */
	@Override
	public void rectangulo( double x1, double y1, double x2, double y2, double anchoArco, 
							double altoArco, boolean relleno, boolean borde, RECT3D rect3d ) 
	{
		final double ancho = x2 - x1, 
					 alto = y2 - y1;		
		final Shape rect;
		
		// rectángulo recto o 3D
		if ( anchoArco <= 0 && altoArco <= 0 )
			rect = rect3d == RECT3D.NINGUNO ? new Rectangle2D.Double( x1, y1, ancho, alto ) : null;
		// rectángulo redondeado
		else
			rect = new RoundRectangle2D.Double( x1, y1, ancho, alto, anchoArco, altoArco );
		
		// relleno
		if ( relleno )
		{
			// color
			if ( g2.getPaint() instanceof Color || rect == null )
			{
				final Color oriColor = g2.getColor();
				g2.setColor( colorRelleno );
				if ( rect != null )
					g2.fill( rect );
				else
					g2.fill3DRect( (int) Math.round(x1), (int) Math.round(y1), 
								   (int) Math.round(ancho), (int) Math.round(alto), 
								   rect3d == RECT3D.RESALTADO );
				g2.setColor( oriColor );
			}
			// gradiente
			else
				g2.fill( rect );
		}
		// borde
		if ( /*!relleno || */borde )
		{
			if ( rect != null )
				g2.draw( rect );
			else
				g2.draw3DRect( (int) Math.round(x1), (int) Math.round(y1), 
							   (int) Math.round(ancho), (int) Math.round(alto), 
							   rect3d == RECT3D.RESALTADO );
		}
	}
	
	@Override
	public void circunferencia( double cx, double cy, double radio, double ang, double arco, 
								CIERRE tipo, boolean relleno, boolean borde )
	{
		final Shape circ;		

		// circunferencia
		if ( arco >= 360. )
			circ = new Ellipse2D.Double( cx-radio, cy-radio, 2*radio, 2*radio );
		// arco
		else
		{
			final int cierre;
			switch ( tipo )
			{
				default:
				case ABIERTO: cierre = Arc2D.OPEN; break;
				case TARTA: cierre = Arc2D.PIE; break;
				case CUERDA: cierre = Arc2D.CHORD;
			}
			circ = new Arc2D.Double( cx-radio, cy-radio, 2*radio, 2*radio, ang, arco, cierre );
		}
		
		drawOrFill( circ, relleno, borde );
	}

	@Override
	public void elipse( double x1, double y1, double x2, double y2, boolean relleno, boolean borde ) 
	{
		drawOrFill( new Ellipse2D.Double( x1, y1, x2 - x1, y2 - y1 ), relleno, borde );
	}

	@Override
	public void poligono( double[] x, double[] y, boolean cerrar, boolean relleno, boolean borde ) 
	{
		if ( x.length != y.length )
			throw new ScriptException( 
								"Las coordenadas del poligono/polilinea son de distinto tamano" );
		
		final Path2D poly = new Path2D.Double();				

		poly.moveTo( x[0], y[0] );
		for( int i = 1; i < x.length; i++ )
		   poly.lineTo( x[i], y[i] );
		if ( cerrar )
			poly.closePath();		

		drawOrFill( poly, relleno, borde );
	}
	
	@Override
	public void ruta( AccionPuntos[] accionPuntos, RUTA regla, boolean relleno, boolean borde ) 
	{
		final Path2D.Double path = new Path2D.Double( 
							regla == RUTA.NO_CERO ? Path2D.WIND_NON_ZERO : Path2D.WIND_EVEN_ODD );
		
		for ( AccionPuntos ap : accionPuntos )
		{
			switch ( ap.accion )
			{
				case MOVER_A: path.moveTo( ap.puntos[0][0], ap.puntos[0][1] ); break;
				case LINEA_A: path.lineTo( ap.puntos[0][0], ap.puntos[0][1] ); break;
				case CURVA_A: path.curveTo( ap.puntos[0][0], ap.puntos[0][1],
											 ap.puntos[1][0], ap.puntos[1][1],
											 ap.puntos[2][0], ap.puntos[2][1] ); break;
				case CUAD_A: path.quadTo( ap.puntos[0][0], ap.puntos[0][1],
						 				   ap.puntos[1][0], ap.puntos[1][1] ); break;
				case CERRAR: path.closePath(); break;
				default: throw new IllegalArgumentException( ap.accion.toString() );
			}
		}
		
		drawOrFill( path, relleno, borde );
	}
	
	private void drawOrFill( Shape figura, boolean relleno, boolean borde )
	{
		if ( relleno )
		{
			// color
			if ( g2.getPaint() instanceof Color )
			{
				final Color oriColor = g2.getColor();
				g2.setColor( colorRelleno );
				g2.fill( figura );
				g2.setColor( oriColor );
			}
			// gradiente
			else
				g2.fill( figura );
		}
		if ( /*!relleno ||*/ borde )
			g2.draw( figura );
	}
	
	@Override
	public void texto( String texto, int posX, int posY, int tama, int sombraX, int sombraY, 
					   String familia, ESTILO estilo ) 
	{
		final int awtEstilo;
		switch (estilo)
		{
			case PLANO: awtEstilo = Font.PLAIN; break;
			case NEGRITA: awtEstilo = Font.BOLD; break;
			case CURSIVA: awtEstilo = Font.ITALIC; break;
			case NEG_CUR: awtEstilo = Font.ITALIC|Font.BOLD; break;
	
			default: awtEstilo = Font.PLAIN;
		}
		
		final Font oriFont = g2.getFont(), nuevaFont = new Font( familia, awtEstilo, tama );
		
		g2.setFont( nuevaFont );
		final FontMetrics fm = g2.getFontMetrics( nuevaFont );
		if ( sombraX != 0 || sombraY != 0 )
		{
			final Color oriColor = g2.getColor();
			g2.setColor( colorRelleno );
			g2.drawString( texto, posX + sombraX, posY + sombraY + fm.getHeight() - fm.getDescent() /*- fm.getAscent()*/ );
			g2.setColor( oriColor );
		}
		g2.drawString( texto, posX, posY + fm.getHeight() - fm.getDescent() /*- fm.getAscent()*/ );
		g2.setFont( oriFont );
	}
	
	@Override
	public int[] medirTexto( String texto, int tama, int sombraX, int sombraY, String familia, 
							 ESTILO estilo ) 
	{
		final int awtEstilo;
		switch (estilo)
		{
			case PLANO: awtEstilo = Font.PLAIN; break;
			case NEGRITA: awtEstilo = Font.BOLD; break;
			case CURSIVA: awtEstilo = Font.ITALIC; break;
			case NEG_CUR: awtEstilo = Font.ITALIC|Font.BOLD; break;
	
			default: awtEstilo = Font.PLAIN;
		}
		
		final FontMetrics fm = g2.getFontMetrics( new Font( familia, awtEstilo, tama ) );
		
		return new int[] { fm.stringWidth( texto ) + sombraX, fm.getHeight() + sombraY };
	}	
	
	public static class KeyStrokeEvent implements AbstractKeyStroke 
	{
		private static final long serialVersionUID = 1L;
		
		final protected KeyEvent kEvent;
		
		public KeyStrokeEvent( KeyEvent kEvent ) 
		{
			this.kEvent = kEvent;
		}
		
		@Override
		public boolean isKeyReleased() { return kEvent.getID() == KeyEvent.KEY_RELEASED; }
		@Override
		public int getModifiers() { return kEvent.getModifiersEx(); }
		@Override
		public String getModifiersText() 
		{ 
			return KeyEvent.getModifiersExText( kEvent.getModifiersEx() ); 
		}
		@Override
		public int getKeycode() { return kEvent.getKeyCode(); }
		@Override
		public char getKeychar() { return kEvent.getKeyChar(); }
		@Override
		public long getTimeStamp() { return kEvent.getWhen(); }
		@Override
		public boolean isAccion() { return kEvent.isActionKey(); }
		@Override
		public LOCALIZACION getLocalizacion() 
		{
			switch ( kEvent.getKeyLocation() ) 
			{
				case KeyEvent.KEY_LOCATION_STANDARD: return LOCALIZACION.ESTANDAR;
				case KeyEvent.KEY_LOCATION_LEFT: return LOCALIZACION.IZQUIERDA;
				case KeyEvent.KEY_LOCATION_RIGHT: return LOCALIZACION.DERECHA;
				case KeyEvent.KEY_LOCATION_NUMPAD: return LOCALIZACION.NUMPAD;
				case KeyEvent.KEY_LOCATION_UNKNOWN: return LOCALIZACION.DESCONOCIDA;
				default: return null;
			}
		}
	}
	
	/**
	 * Implementación de evento de click/toque para AWT/Swing 
	 */
	public static class RatonEvent implements AbstractRatonEvent
	{
		private static final long serialVersionUID = 1L;

		final protected MouseEvent mEvent;
		
		public RatonEvent( MouseEvent mEvent ) 
		{
			this.mEvent = mEvent;
		}
		
		public MouseEvent getMouseEvent() { return mEvent; }
		
		@Override
		public RATON_ID getId() 
		{ 
			switch ( mEvent.getID() )
			{
				case MouseEvent.MOUSE_PRESSED: return RATON_ID.PRESSED;
				case MouseEvent.MOUSE_RELEASED: return RATON_ID.RELEASED;
				case MouseEvent.MOUSE_CLICKED: return RATON_ID.CLICKED;
				case MouseEvent.MOUSE_MOVED: return RATON_ID.MOVED;
				case MouseEvent.MOUSE_DRAGGED: return RATON_ID.DRAGGED;
				case MouseEvent.MOUSE_ENTERED: return RATON_ID.ENTERED;
				case MouseEvent.MOUSE_EXITED: return RATON_ID.EXITED;
				case MouseEvent.MOUSE_WHEEL: return RATON_ID.WHEEL;
				default: return null;
			}
		}
		
		@Override
		public BOTON getButton() 
		{
			switch( mEvent.getButton() )
			{
				case MouseEvent.BUTTON1: return BOTON.BOTON1;
				case MouseEvent.BUTTON2: return BOTON.BOTON2;
				case MouseEvent.BUTTON3: return BOTON.BOTON3;
				case MouseEvent.NOBUTTON:
				default: return BOTON.NO_BOTON;
			}
		}
		
		@Override
		public int getClicks() { return mEvent.getClickCount(); }
		
		@Override
		public int[] getPosicion() { return new int[] { mEvent.getX(), mEvent.getY() }; }
		
		@Override
		public int[] getPosicionEnPantalla()
		{ 
			return new int[] { mEvent.getXOnScreen(), mEvent.getYOnScreen() }; 
		}
		
		@Override
		public long getTimeStamp() { return mEvent.getWhen(); }
		
		@Override
		public double getRotacion() 
		{
			return mEvent instanceof MouseWheelEvent 
				   ? ((MouseWheelEvent) mEvent).getPreciseWheelRotation() 
				   : 0.; 
		}
		
	}  // class RatonEvent
	
}  // class JMEPrimitivas2DParaSwing
</code></pre>
<hr/>
<p>Implementación de <code>JMEPrimitivas2DParaSwing</code> en <i>JMEScriptGUI</i>:</p>
<pre><code class="java">package jmescriptgui;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.stream.Collectors;

import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JColorChooser;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JToolBar;
import javax.swing.KeyStroke;
import javax.swing.filechooser.FileNameExtensionFilter;

import jme.script.ctx2d.AbstractPrimitivas2D;
import swing_primitivas.JMEPrimitivas2DParaSwing;

/**
 * Implementación de las primitivas de interfaz gráfico de JMEScript para JMEScriptGUI 
 * @author Miguel Alejandro Moreno Barrientos
 * @since 0.1.2, JME 0.6.2.0, JMEScript 0.2.0
 */
public class JmeScriptGuiPrimitivas2D extends JMEPrimitivas2DParaSwing
{
	final private GUI gui;  // componente padre
	private Dialogo ctxDialog;  // diálogo que contiene el lienzo de dibujo
	
	public JmeScriptGuiPrimitivas2D( GUI gui ) 
	{
		super();
		this.gui = gui;
	}


	///////////////////////////////////
	// PRIMITIVAS GRÁFICAS
	///////////////////////////////////	
	
	/**
	 * Esta implementación incluye tostadas y usa la superclase para los mensajes
	 */
	@Override
	public void mostrarMensaje( String msj, MSJ tipo, Integer posX, Integer posY, Integer tiempo )
	{
		// diálogo de mensaje por defecto
		if ( tiempo == null || tiempo < 0 )
			super.mostrarMensaje( msj, tipo, posX, posY, tiempo );
		// tostada
		else
		{
			final Point point = posX == null || posY == null ? null : new Point( posX, posY );
			switch( tipo )
			{
				case OK: ToastFactory.createOkToast( msj, point, tiempo ).showToast(); break;
				case WARNING: ToastFactory.createWarningToast(msj,point,tiempo).showToast(); break;
				case ERROR: ToastFactory.createErrorToast( msj, point, tiempo ).showToast(); break;
				default: ToastFactory.createToast( msj, point, tiempo ).showToast();
			}
		}
	}	
	
	@Override
	public String getUIName() { return GUI.APPNAME; }
	
	@Override
	public String getUIVersion() { return GUI.VERSION; }
	
	@Override
	public String getPrim2DName() { return GUI.APPNAME + " Primitivas2D"; }
	
	@Override
	public String getPrim2DVersionName() 
	{ 
		return super.getPrim2DVersionName() + " para " + GUI.APPNAME; 
	}
	
	@Override
	public GUI getPadre() { return gui; }
	
	@Override
	public void iniciarContexto(int indice, int ancho, int alto, int posX, int posY, String titulo) 
	{
		// crear diálogo gráfico y canvas
		ctxDialog = new Dialogo( indice, ancho, alto, posX, posY, titulo );
		ctxDialog.setVisible(true);
		ctxDialog.pack();
		if ( posX >= 0 && posY >= 0 )
			ctxDialog.setLocation( posX, posY );
		else
			ctxDialog.setLocationRelativeTo( gui );
		ctxDialog.canvas.requestFocusInWindow();
	}

	@Override
	public void finalizarContexto() 
	{
		if ( esContextoIniciado() && ctxDialog.isVisible() )
		{
			ctxDialog.setVisible( false );
			ctxDialog.dispose();
			ctxDialog = null;
		}
	}
	
	@Override
	public boolean esContextoIniciado() { return ctxDialog != null; }
	
	@Override
	public void repintar( int indice ) 
	{
		if ( !esContextoIniciado() )
			throw new IllegalStateException( 
								"El contexto " + indice + " no esta inicializado o esta cerrado" );
		ctxDialog.canvas.repaint();
		
		synchronized ( ctxDialog )
		{
			ctxDialog.imagenActual = new BufferedImage( 
									ctxDialog.backImage.getWidth(), ctxDialog.backImage.getHeight(), 
									BufferedImage.TYPE_INT_RGB );
			ctxDialog.imagenActual.getGraphics().drawImage( 
								ctxDialog.backImage, 0, 0, ctxDialog.canvas.getBackground(), null );			
		}
	}
	
	@Override
	public int getAncho() 
	{ 
		return esContextoIniciado() ? ctxDialog.backImage.getWidth() : -1; 
	}
	
	@Override
	public int getAlto()
	{ 
		return esContextoIniciado() ? ctxDialog.backImage.getHeight() : -1; 
	}
	
	@Override
	public Map<Object,Object> getPropiedadesEntorno() 
	{
		final Properties prop = System.getProperties();
		prop.putAll( System.getenv()
					 .entrySet()
					 .parallelStream()
					 .collect( Collectors.toMap( entry -> (Object) entry.getKey(), 
							 					 entry -> (Object) entry.getValue() ) ) );
		
		return Collections.unmodifiableMap(prop);
	}
	
	
	///////////////////
	// CLASE DIALOGO
	///////////////////
	
	private static final JColorChooser COLOR_CHOOSER = new JColorChooser();  // selector de color del lienzo
	private static final JFileChooser fileChooser = new JFileChooser();  // selector de archivo para guardar lienzo
	
	static
	{
		fileChooser.addChoosableFileFilter( 
									  new FileNameExtensionFilter( "imagen JPEG", "jpg", "jpeg" ) );
		fileChooser.addChoosableFileFilter( new FileNameExtensionFilter( "imagen PNG", "png" ) );
		fileChooser.addChoosableFileFilter( new FileNameExtensionFilter( "imagen GIF", "gif" ) );
		fileChooser.setAcceptAllFileFilterUsed(false);
	}
	
	/**
	 * Diálogo creado en {@link JmeScriptGuiPrimitivas2D#iniciarContexto} que contiene el lienzo
	 * y opciones de manipulación de éste
	 */
	private class Dialogo extends JDialog
	{
		private JPanel canvas;
		private BufferedImage backImage,		
							  imagenActual;

		@SuppressWarnings("serial")
		public Dialogo( int indice, int ancho, int alto, int posX, int posY, String titulo ) 
		{
			super( gui, titulo != null ? titulo : "Contexto  " + indice );
			
			// TOOLBAR
			final JToolBar toolbar = new JToolBar( "Herramientas lienzo" );
			getContentPane().add( toolbar, BorderLayout.NORTH );
			
			// BUTTON selector de fondo del lienzo
			toolbar.add( new JButton( new ImageIcon( getClass().getResource( 
	   												GUI.resourcePath + "color_select.png" ) ) ) {
				{
					setHideActionText(true);
					setToolTipText( "Color de fondo del lienzo" );
					addActionListener( e -> {
						COLOR_CHOOSER.setColor( canvas.getBackground() );
						JColorChooser.createDialog( ctxDialog, "Color del fondo del lienzo", true, 
													COLOR_CHOOSER, null, null ).setVisible(true);
						final Color nuevoColor = COLOR_CHOOSER.getColor();
						if ( nuevoColor != null )
						{
							setFondo( new JSColor( nuevoColor ) );
							/*limpiar( 0, 0, getAncho(), getAlto(), null );
							repintar( indice );*/
						}
					});
				}
			});
			// BUTTON repintar
			toolbar.add( new JButton( new ImageIcon( getClass().getResource( 
										   			GUI.resourcePath + "repintar_icon.png" ) ) ) {
				{
					setHideActionText(true);
					setToolTipText( "Repintar lienzo" );
					addActionListener( e -> canvas.repaint() );
				}
			});
			// BUTTON guardar lienzo
			toolbar.add( new JButton( new ImageIcon( getClass().getResource( 
														GUI.resourcePath + "save_icon.png" ) ) ) {
				{
					setHideActionText(true);
					setToolTipText( "Guardar lienzo como imagen" );
					addActionListener( e -> {
						fileChooser.setDialogTitle( 
											"Guardar lienzo de <" + ctxDialog.getTitle() + ">" );
						if ( fileChooser.showSaveDialog(ctxDialog) == JFileChooser.APPROVE_OPTION )
						{
							String filename = fileChooser.getSelectedFile().getAbsolutePath(), ext;
							final int extIdx = filename.lastIndexOf( '.' );
							if ( extIdx >= 0 )
								ext = filename.substring( extIdx+1 ).toLowerCase();
							else
							{
								ext = ((FileNameExtensionFilter) fileChooser.getFileFilter())
									  .getExtensions()[0];
								filename += "." + ext;
							}
							final BufferedImage imagenFinal;
							synchronized ( ctxDialog )  // asegurar que la imagen actual está actualizada
							{
								if ( ext.equals("jpg") || ext.equals("jpeg") )  // quitar alfa en JPEG
								{
									imagenFinal = new BufferedImage( 
												imagenActual.getWidth(), imagenActual.getHeight(), 
												BufferedImage.TYPE_INT_RGB );
									imagenFinal.getGraphics().setColor( canvas.getBackground() );
									imagenFinal.getGraphics().drawImage( 
												imagenActual, 0, 0, canvas.getBackground(), null );
								}
								else
									imagenFinal = imagenActual;
							}
							try 
							{
							    ImageIO.write( imagenFinal, ext, new File(filename) );
							} 
							catch (IOException ex) 
							{
								JOptionPane.showMessageDialog( gui, 
														   	   ex.getMessage(), 
														   	   "Error al salvar " + filename, 
														   	   JOptionPane.ERROR_MESSAGE );
							}
						}
					});
				}
			});
			// BUTTON tamaño original
			toolbar.add( new JButton( new ImageIcon( getClass().getResource( 
														GUI.resourcePath + "pack_icon.png" ) ) ) {
				{
					setHideActionText(true);
					setToolTipText( "Tamaño por defecto" );
					addActionListener( e -> ctxDialog.pack() );
				}
			});
			// BUTTON cerrar todo
			toolbar.add( new JButton( new ImageIcon( getClass().getResource( 
												GUI.resourcePath + "cerrar_todo_icon.png" ) ) ) {
				{
					setHideActionText(true);
					setToolTipText( "Cerrar todo" );
					addActionListener( e -> {
						final List<AbstractPrimitivas2D> primitivas = 
															gui.runningScript.getListaPrimitivas(); 
						primitivas.forEach( prim2d -> prim2d.finalizarContexto() );
					});
				}
			});
			
			// crear imagen de respaldo del lienzo
			backImage = new BufferedImage(ancho, alto, BufferedImage.TYPE_INT_ARGB);
			
			// crear canvas
			canvas = new JPanel() {
				@Override
				protected void paintComponent(Graphics g) {
					super.paintComponent(g);
					g.drawImage( backImage, 
								 0, 0, getWidth(), getHeight(), 
								 0, 0, backImage.getWidth(), backImage.getHeight(), 
								 null );
				}
			};
			canvas.setBackground( Color.BLACK );
			canvas.setPreferredSize( new Dimension( ancho, alto ) );
			canvas.setFocusable(true);
			// keylistener para detectar key strokes en el lienzo 
			canvas.addKeyListener( new KeyAdapter() {
				@Override
				public void keyPressed(KeyEvent e) 
				{
					synchronized( getStrokeList() )
					{
						getStrokeList().add( new KeyStrokeEvent( e ) );
					}
				}
				@Override
				public void keyReleased(KeyEvent e)
				{
					synchronized( getStrokeList() )
					{
						getStrokeList().add( new KeyStrokeEvent( e ) );
					}
				};
			});
			// mouseadapter para detectar eventos de ratón
			final MouseAdapter mouseAdap = new MouseAdapter() {
				@Override
				public void mousePressed( MouseEvent e ) 
				{
					synchronized( getRatonEventList() )
					{
						getRatonEventList().add( new RatonEvent( e ) );
					}
				}
				@Override
				public void mouseReleased(MouseEvent e)
				{
					synchronized( getRatonEventList() )
					{
						getRatonEventList().add( new RatonEvent( e ) );
					}
				}
				@Override
				public void mouseEntered(MouseEvent e) 
				{
					synchronized( getRatonEventList() )
					{
						getRatonEventList().add( new RatonEvent( e ) );
					}
				}
				@Override
				public void mouseExited( MouseEvent e ) 
				{
					synchronized( getRatonEventList() )
					{
						getRatonEventList().add( new RatonEvent( e ) );
					}
				};
				@Override
				public void mouseDragged(MouseEvent e) 
				{
					synchronized( getRatonEventList() )
					{
						getRatonEventList().add( new RatonEvent( e ) );
					}
				}
				@Override
				public void mouseMoved(MouseEvent e) 
				{
					synchronized( getRatonEventList() )
					{
						getRatonEventList().add( new RatonEvent( e ) );
					}
				}
				@Override
				public void mouseWheelMoved( MouseWheelEvent e ) 
				{
					synchronized( getRatonEventList() )
					{
						getRatonEventList().add( new RatonEvent( e ) );
					}
				}
			};
			canvas.addMouseListener( mouseAdap );
			canvas.addMouseMotionListener( mouseAdap );
			canvas.addMouseWheelListener( mouseAdap );
			
			add( canvas );
			
			// cerrar ventana
			addWindowListener( new WindowAdapter() {
				public void windowClosing(WindowEvent e) 
				{
					finalizarContexto();
				};
			});
			
			// añadir acción pausa/reanudar
			getRootPane().getActionMap().put( "pause_resume", gui.actionMap.get( "pause_resume" ) );
			getRootPane().getInputMap( JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT )
						 .put( KeyStroke.getKeyStroke( "PAUSE" ), "pause_resume" );
			
			// definir Graphics2D desde imagen de respaldo
			final Graphics2D g2 = backImage.createGraphics();
			//g2.setColor( Color.BLACK );  // defecto blanco
			setGraphics( g2 );
			// establecer alta calidad
			g2.setRenderingHint( RenderingHints.KEY_TEXT_ANTIALIASING,
		  				 		 RenderingHints.VALUE_TEXT_ANTIALIAS_ON );
			g2.setRenderingHint( RenderingHints.KEY_ANTIALIASING, 
			  			 		 RenderingHints.VALUE_ANTIALIAS_ON );
			g2.setRenderingHint( RenderingHints.KEY_RENDERING, 
				  			 	 RenderingHints.VALUE_RENDER_QUALITY );
			g2.setRenderingHint( RenderingHints.KEY_ALPHA_INTERPOLATION, 
				  			 	 RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY );
			g2.setRenderingHint( RenderingHints.KEY_COLOR_RENDERING, 
				  			 	 RenderingHints.VALUE_COLOR_RENDER_QUALITY );
			g2.setRenderingHint( RenderingHints.KEY_DITHERING, 
				  			 	 RenderingHints.VALUE_DITHER_ENABLE );
			g2.setRenderingHint( RenderingHints.KEY_INTERPOLATION,
				    			 RenderingHints.VALUE_INTERPOLATION_BILINEAR);
		}
		
		private static final long serialVersionUID = 1L;

	}  // class Dialogo
	
}  // class JMEScriptGuiPrimitivas2D
</code></pre>

</section>

<br/><br/>
<h3 class="subSection" id="abstractsql">Implementación de soporte SQL</h3>
<section class="content">
<br/>
<p>
Para implementar soporte SQL a una aplicación que use <code>JMEScript</code>, sólo es necesario implentar el interfaz 
<code>jme.script.sql.AbstractSQL</code>, y asignar la clase implementante al script, antes de ejecutarlo, mediante <code>Script#getListaSgbdrSql#add</code> 
o <code>Script#setListaSgbdrSql</code> para asignar una lista de SGBDR.
</p>
<pre><code class="java">package jme.script.sql;

/**
 * Interfaz para la representación abstracta de una conexión a SGBDR mediante SQL
 * @author Miguel Alejandro Moreno Barrientos, (C)2020-2021
 * @since 0.6.2.0, JMEScript 0.2.0
 */
public interface AbstractSql
</code></pre>
<p>Este interfaz contiene cinco métodos para implentar la apertura, cierre, ejecución de consultas y lectura de datos de la consulta. Al final de esta
sección se muesta un ejemplo de implementación para MySQL con el Conector-J que utiliza <i>JMEScriptGUI</i>.</p>
<ul>
<li>El método <b>conectar</b> establece la conexión con la base de datos y en caso de fallo lanza una excepción apropiada
<pre><code class="java">/**
 * Conectar a la BBDD
 * @param idConexion identificador de conexión, para diferenciarla de múltiples conexiones
 * @param host host de la BBDD
 * @param usuario nombre de usuario de la BBDD
 * @param password contraseña de la BBDD
 * @throws Throwable error en la conexión
 */
void conectar( Object idConexion, String host, String usuario, String password ) throws Throwable;
</code></pre>
</li>
<li>El método <b>cerrar</b> termina la conexión con la base de datos a partir del identificador de conexión del método <i>conectar</i>. En caso de fallo
lanza una excepción apropiada
<pre><code class="java">/**
 * Cerrar la conexión 
 * @param idConexion identificador de conexión
 * @throws Throwable error al cerrar la conexión
 */
void cerrar( Object idConexion ) throws Throwable;
</code></pre>
</li>
<li>El método <b>ejecutar</b> efectúa una consulta contra la base de datos y le asigna un identificador, y en caso de fallo lanza la excepción apropiada
<pre><code class="java">/**
 * Ejecuta una sentencia SQL
 * @param idConexion identificador de conexión
 * @param idSentencia identificador de la sentencia, para poder acceder a sus resultados 
 *        particulares
 * @param sql sentencia SQL del SGBDR utilizado
 * @return {@code true} si el valor devuelto es un conjunto de resultados o {@code false} si
 * no hay resultados o es conteo de actualizaciones
 * @throws Throwable error en la sentencia
 */
boolean ejecutar( Object idConexion, Object idSentencia, String sql ) throws Throwable;
</code></pre>
</li>
<li>El método <b>getData</b> (sin columnas) devuelve secuencialmente los registros de una consulta o conteo de actualizaciones
para una sola columna o para todas si se asigna a <code>nombreCol</code> la cadena '*', y en caso de fallo lanza la excepción apropiada
<pre><code class="java">/**
 * Devuelve el siguiente registro (fila) del resultado de la sentencia, 
 * o el conteo de actualizaciones para una sola columna de la tabla o para todas <b>'*'</b>
 * @param idConexion identificador de conexión
 * @param idSentencia identificador de sentencia
 * @param nombreCol nombre de la columna de la que se quiere obtener información
 * @return registro o conteo de actualizaciones (int) o {@code null} si no hay más registros
 * @throws Throwable no se pueden obtener más resultados o la sentencia está terminada
 * @see #getData(Object, Object, String[])
 */
Object getData( Object idConexion, Object idSentencia, String nombreCol ) throws Throwable;
</code></pre>
</li>
<li>El método <b>getData</b> (con columnas) hace lo mismo que el método anterior para las columnas especificadas
<pre><code class="java">/**
 * Devuelve el siguiente registro (fila) del resultado de la sentencia, 
 * o el conteo de actualizaciones para las columnas seleccionadas
 * @param idConexion identificador de conexión
 * @param idSentencia identificador de sentencia
 * @param arrayCol nombres de las columnas de las que se quiere obtener información
 * @return registro o conteo de actualizaciones
 * @throws Throwable no se pueden obtener más resultados o la sentencia está terminada
 * @see #getData(Object, Object, String)
 */
Object getData( Object idConexion, Object idSentencia, String[] arrayCol ) throws Throwable;
</code></pre>
</li>
</ul>
<br/>
<hr/>
<br/>
<p>La clase <code>jmescriptgui.MySql</code> es una implementación de <code>AbstractSql</code> para <i>JMEScriptGUI</i> usando
el <a href="https://dev.mysql.com/downloads/connector/j/">Conector-J</a> para MySQL:</p>
<pre><code class="java">package jmescriptgui;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

import jme.script.sql.AbstractSql;

/**
 * Implementación MySQL del interfaz de conexión ente SGBDR y JMEScript para JMEScriptGUI.&lt;br>
 * Usa el Conector-J 
 * @author Miguel Alejandro Moreno Barrientos, (C)2020-2021
 */
public class MySql implements AbstractSql 
{
	/** Las conexiones activas se guardan aquí */
	private final Map&lt;Object,Connection> mapaConexiones = new HashMap&lt;>();
	/** Las sentencias en activo se guardan aquí */
	private final Map&lt;Object,Map&lt;Object,Statement>> mapaSentencias = new HashMap&lt;>();
	
	@Override
	public void conectar( Object idConexion, String host, String usuario, String password ) throws SQLException
	{
		// crear conexión
		final Connection con = DriverManager.getConnection( host, usuario, password );
		// si no ha habido excepción, mapear la conexión
		mapaConexiones.put( idConexion, con );
		mapaSentencias.put( idConexion, new HashMap&lt;Object,Statement>() );
	}
	
	@Override
	public void cerrar( Object idConexion ) throws SQLException
	{
		// accede y comprueba la conexión especificada
		final Connection con = mapaConexiones.get( idConexion );
		if ( con == null )
			throw new SQLException( "Conexion " + idConexion + " inexistente" );
		// intenta cerrarla (SQLException if a database access error occurs)
		con.close();
		// si no ha habido excepción, elimina la conexión y sentencias del mapa 
		mapaConexiones.remove( idConexion );
		mapaSentencias.remove( idConexion );
	}

	@Override
	public boolean ejecutar( Object idConexion, Object idSentencia, String sql ) throws SQLException
	{
		// accede y comprueba la conexión especificada
		final Connection con = mapaConexiones.get( idConexion );
		if ( con == null )
			throw new SQLException( "Conexion " + idConexion + " inexistente" );
		// crea y ejecuta la sentencia
		final Statement stmt = con.createStatement();		
		final boolean res = stmt.execute( sql );
		// guarda la sentencia en su conexión
		mapaSentencias.get( idConexion ).put( idSentencia, stmt );
		
		return res;
	}
	
	@Override
	public Object getData( Object idConexion, Object idSentencia, String nombreCol ) throws Throwable 
	{
		if ( mapaConexiones.get( idConexion ) == null )
			throw new SQLException( "Conexion " + idConexion + " inexistente" );

		final Statement stmt = mapaSentencias.get( idConexion ).get( idSentencia );
		if ( stmt == null )
			throw new SQLException( "Sentencia " + idSentencia + " inexistente" );
		
		if ( stmt.getUpdateCount() >= 0 )
			return stmt.getUpdateCount();

		// leer nombre de columnas
		final int numColumnas = stmt.getResultSet().getMetaData().getColumnCount();
		final String[] arrayCol = new String[ numColumnas ];
		for ( int i = 1; i &lt;= numColumnas; i++ )
			arrayCol[i-1] = stmt.getResultSet().getMetaData().getColumnName(i);

		// leer siguiente registro
		if ( stmt.getResultSet().next() )
		{
			return nombreCol.trim().equals("*")
				   ? getData( idConexion, idSentencia, arrayCol )
				   : stmt.getResultSet().getObject( nombreCol );
		}
		// limpiar sentencia del mapa de sentencias
		else
		{
			mapaSentencias.get( idConexion ).remove( idSentencia );
			
			return null;
		}
	}
	
	@Override
	public Object getData( Object idConexion, Object idSentencia, String[] arrayCol ) throws Throwable 
	{
		// obtener sentencia
		if ( mapaConexiones.get( idConexion ) == null )
			throw new SQLException( "Conexion " + idConexion + " inexistente" );

		final Statement stmt = mapaSentencias.get( idConexion ).get( idSentencia );
		if ( stmt == null )
			throw new SQLException( "Sentencia " + idSentencia + " inexistente" );

		// leer siguiente registro 
		if ( stmt.getResultSet().next() )
		{
			// diccionario columna/dato
			final Map&lt;String,Object> res = new LinkedHashMap&lt;>();

			for ( String col : arrayCol )
				res.put( col, stmt.getResultSet().getObject( col ) );
			
			return res;
		}
		// limpiar sentencia del mapa de sentencias
		else
		{
			mapaSentencias.get( idConexion ).remove( idSentencia );
			
			return null;
		}
	}
}
</code></pre>
Asignación de un gestor MySQl en <i>JMEScriptGUI</i> antes del lanzamiento del script,
<pre><code class="java">&hellip;
// iniciar gestor de bases de datos relacional (1 gestor mysql)
gui.runningScript.getListaSgbdrSql().add( new MySql() );
&hellip;
</code></pre>
</section>

<br/><br/>
<h3 class="subSection" id="accioncode">Implementación de acciones</h3>
<section class="content">
<br/>
<p>
Una aplicación que quiera utilizar acciones personalizadas sobre la propia aplicación debe implementar el interfaz <code>AbstractAppAcciones</code> y
cargar la clase implementante en el script, antes de lanzarlo, mediante el método <code>Script#setAppAcciones</code>
</p>
<pre><code class="java">package jme.script.appacciones;

/**
 * Interfaz para la implementación de acciones reconocibles por JMEScript
 * @author Miguel Alejandro Moreno Barrientos
 * @since 0.6.2.0, JMEScript 0.2.0
 */
public interface AbstractAppAcciones 
{
	/**
	 * Realiza la acción seleccionada y pasa/recibe opcionalmente parámetros 
	 * y resultado de la acción
	 * @param accionID identificador único de la acción
	 * @param parametros parámetro o parámetros como array que requiere la acción (o null)
	 * @return valor devuelto por la acción (o null)
	 */
	Object efectuarAccion( String accionID, Object parametros );
}
</code></pre>
<p>El método <code>#efectuarAccion</code> puede ejecutar la acción especificada mediante un mapa de acciones, o un simple <code>switch</code>, o cualquier
método que se desee implementar para efectuar la acción.</p>
<p>En <i>JMEScriptGUI</i>, la clase <code>JMEScriptGuiAppAcciones</code> implementa éste interfaz mediante un simple <code>switch</code>:
<pre><code class="java">package jmescriptgui;

import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.WindowEvent;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Objects;

import javax.swing.JFrame;
import javax.swing.SwingUtilities;

import com.sun.istack.internal.Nullable;

import jme.Expresion;
import jme.excepciones.ConversionException;
import jme.script.appacciones.AbstractAppAcciones;

/**
 * Implementación para JMEScriptGUI de {@code AbstractAppAcciones} para la ejecución de acciones
 * sobre el IDE mediante script
 * @author Miguel Alejandro Moreno Barrientos, (C)2020-2021
 * @since JMEScriptGUI 0.1.2.0
 */
public class JMEScriptGuiAppAcciones implements AbstractAppAcciones
{
	private final GUI gui;
	
	JMEScriptGuiAppAcciones( GUI gui ) 
	{
		this.gui = gui;
	}
	
	@Override
	public @Nullable Object efectuarAccion( String accionID, @Nullable Object parametros ) 
	{
		switch( accionID.toLowerCase() )
		{
			case "accion.cerrar": gui.dispatchEvent( new WindowEvent( gui, WindowEvent.WINDOW_CLOSING ) ); break;

			case "accion.flush": gui.actionMap.get( "flush" ).actionPerformed( null ); break;			
			
			case "set.mul_implicita": Expresion.setMultiplicacionImplicita( (boolean) parametros ); 
									  break;  // !Nota: no tiene efecto en la primera ejecución
			case "get.mul_implicita": return Expresion.isMultiplicacionImplicita();
			
			case "accion.maximizar": gui.setExtendedState( JFrame.MAXIMIZED_BOTH ); break;
			case "accion.minimizar": gui.setExtendedState( JFrame.ICONIFIED ); break;
			
			case "get.console": return System.out != gui.defOut;
			case "accion.console": gui.actionMap.get( "console" ).actionPerformed( 
						    new ActionEvent( gui.togConsole, ActionEvent.ACTION_PERFORMED, null ) );
			
			case "get.flip": return gui.outerSplitPanel.getOrientation();			
			case "accion.flip": gui.actionMap.get( "flip" ).actionPerformed( 
							   new ActionEvent( gui.btnFlip, ActionEvent.ACTION_PERFORMED, null ) );

			case "get.wrap": return gui.taConsola.getLineWrap();			
			case "accion.wrap": gui.actionMap.get( "wrap_console" ).actionPerformed( 
				  			   new ActionEvent( gui.togWrap, ActionEvent.ACTION_PERFORMED, null ) );

			case "set.font_consola":
			{
				final Map<?,?> fontParam = (Map<?,?>) parametros;
				gui.taConsola.setFont( new Font( fontParam.get( "name" ).toString(),
											 	 ((Number) fontParam.get( "style" )).intValue(),
											 	 ((Number) fontParam.get( "size" )).intValue() ) );
				break;
			}
			
			case "get.spin_salida": return EnhancedMapUtils.putIntoMap( 
										   new LinkedHashMap<Object,Object>(),
										   "value", gui.spinSalidaMenu.getValue(),
										   "next_value", gui.spinSalidaMenu.getNextValue(),
										   "previousValue", gui.spinSalidaMenu.getPreviousValue() );
			case "set.spin_salida":
			{
				try
				{
					final int value = ((Number) parametros).intValue();
					SwingUtilities.invokeLater( () -> gui.spinSalidaMenu.setValue( value ) );
				}
				catch ( ClassCastException e )
				{
					throw new ConversionException( "Al establecer longitud de salida en consola", 
												   Integer.class, parametros.getClass(), e );
				}
				break;
			}		
			
			case "debug.threads":
			{
				final Thread[] tarray = new Thread[ Thread.activeCount()+1 ];
				Thread.enumerate( tarray );

				return Arrays.stream( tarray )
							 .filter( Objects::nonNull )
							 .map( t -> t.toString() + ": " + t.getState() )
							 .toArray( String[]::new );
			}
		}
		
		return null;
	}
	
}  // JMEScriptGuiAppAcciones
</code></pre>
<p>Cargar en el script, antes de ejecutar, la clase anterior:</p>
<pre><code class="java">&hellip;
// añadir control de acciones de la aplicación
gui.runningScript.setAppAcciones( new JMEScriptGuiAppAcciones( gui ) );
&hellip;
</code></pre>

</section>

</div>  <!-- DEVELOPERS -->


<!-- EJEMPLOS -->
<br/><br/>
<h2 class="subtitle" id="examples">Ejemplos de script para descargar</h2><br/>

<div class="tema content">
<p class="content" style="font-size: 1.5em">
	<a href="scripts/factorial.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/factorial.jmes"><b>factorial.jmes</b></a>
</p>
<p class="content" style="font-size: 1.5em">
	<a href="scripts/primos_gemelos.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/primos_gemelos.jmes"><b>primos_gemelos.jmes</b></a>
</p>
<p class="content" style="font-size: 1.5em">
	<a href="scripts/leer_puntos.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/leer_puntos.jmes"><b>leer_puntos.jmes</b></a>
</p>
<p class="content" style="font-size: 1.5em">
	<a href="scripts/numeros_palindromicos.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/numeros_palindromicos.jmes"><b>numeros_palindromicos.jmes</b></a>
</p>
<p class="content" style="font-size: 1.5em">
	<a href="scripts/palindromos_retardados.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/palindromos_retardados.jmes"><b>palindromos_retardados.jmes</b></a>
</p>
<p class="content" style="font-size: 1.5em">
	<a href="scripts/libre_cuadrados.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/libre_cuadrados.jmes"><b>libre_cuadrados.jmes</b></a>
</p>
<p class="content" style="font-size: 1.5em">
	<a href="scripts/frase_invertida.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/frase_invertida.jmes"><b>frase_invertida.jmes</b></a>
</p>
<p class="content" style="font-size: 1.5em">
	<a href="scripts/bola_loca.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/bola_loca.jmes"><b>bola_loca.jmes</b></a>
</p>
<p class="content" style="font-size: 1.5em">
	<a href="scripts/aguanta.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/aguanta.jmes"><b>aguanta.jmes</b></a>
</p>
<p class="content" style="font-size: 1.5em">
	<a href="scripts/2048.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/2048.jmes"><b>2048.jmes</b></a>
</p>
<p class="content" style="font-size: 1.5em">
	<a href="scripts/sql_visor.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/sql_visor.jmes"><b>sql_visor.jmes</b></a>
</p>
<p class="content" style="font-size: 1.5em">
	<a href="scripts/pong.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/pong.jmes"><b>pong.jmes</b></a>
</p>
<p class="content" style="font-size: 1.5em">
	<a href="scripts/grafos_jme.jmes" download><img src="images_jmes/download.png"/></a>&nbsp;&nbsp;
	<a class="discLink monospace" href="scripts/grafos_jme.jmes"><b>grafos_jme.jmes</b></a>
</p>
</div>

<br/>
<img style="margin-top:64px" class="centerImg" src="images_jmes/jmescript_logo.png" width=128px/>

<hr/>

<button onclick="topFunction()" id="myBtn" title="Ir arriba">^</button>

<footer class="final">
	<p>
		Lenguaje JMEScript <span class="versionJMS"></span> // <span class="author"></span>, <span class="copyright"></span>
	</p>
</footer>

</body>

</html>